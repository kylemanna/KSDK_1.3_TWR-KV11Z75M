<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Kinetis SDK v.1.3 API Reference Manual: SPI Master Peripheral Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fs_logo.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Kinetis SDK v.1.3 API Reference Manual
   &#160;<span id="projectnumber">Rev. 0</span>
   </div>
   <div id="projectbrief">Freescale Semiconductor, Inc.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__SPI__DRV__MasterDriver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">SPI Master Peripheral Driver<div class="ingroups"><a class="el" href="group__spi.html">Serial Peripheral Interface (SPI)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p>This section describes the programming interface of the SPI master mode peripheral driver. The SPI master mode peripheral driver transfers data to and from the external devices on the SPI bus in master mode. It provides an easy way to transfer buffers of data with a single function call.</p>
<p>The driver is separated into two implementations: interrupt-driven and DMA-driven. The interrupt-driven driver uses interrupts to alert the CPU that the SPI module needs to service the SPI data transmit and receive operations. The DMA-driven driver uses the DMA module to transfer data between the buffers located in memory and the SPI module transmit/receive buffers/FIFOs. Note that some SPI modules may not support DMA transfers and this is distinguished in the driver using the feature name "FSL_FEATURE_SPI_HAS_DMA_SUPPORT". The interrupt-driven and DMA-driven driver APIs are distinguished by the keyword "dma" in the source file name and by the keyword "Dma" in the API name. Each set of drivers have the same API functionality and are described in the following sections. Note that the DMA-driven driver also uses interrupts to alert the CPU that the DMA has completed its transfer or that one final piece of data still needs to be received which is handled by the IRQ handler in the DMA-driven driver. In both the interrupt and DMA drivers, the SPI module interrupts are enabled in the NVIC. In addition, the DMA driven driver requests channels from the DMA module. Also, subsequent sections refer to either set of drivers as the "SPI master driver" when discussing items that pertain to either driver. Note, when using the DMA-driven SPI driver, initialize the DMA module. An example is shown later under the Initialization section.</p>
<p>The following is a basic step-by-step overview of how to initialize and transfer SPI data. For API specific examples, refer to the examples below. The following uses the interrupt-driven APIs and a blocking transfer to illustrate a high-level step-by-step usage. The usage of DMA driver is similar to interrupt-driven driver. Keep in mind that using interrupt and DMA drivers in the same runtime application is not normally recommended because the SPI interrupt handler needs to be changed. The interrupt driver calls SPI_DRV_IRQHandler() and DMA driver calls SPI_DRV_DmaIRQHandler(). Refer to files fsl_spi_irq.c and fsl_spi_dma_irq.c for an example of these function calls.</p>
<div class="fragment"><div class="line"><span class="comment">// Init the SPI</span></div>
<div class="line"><a class="code" href="group__SPI__DRV__MasterDriver.html#gac1f30c149f26ad5230b65b670a232e92">SPI_DRV_MasterInit</a>(masterInstance, &amp;spiMasterState, &amp;userConfig);</div>
<div class="line"><span class="comment">// Configure ther SPI bus</span></div>
<div class="line"><a class="code" href="group__SPI__DRV__MasterDriver.html#ga0562675eefc63ce119738e9f11b7b55f">SPI_DRV_MasterConfigureBus</a>(masterInstance, &amp;spiDevice, &amp;calculatedBaudRate);</div>
<div class="line"><span class="comment">// Perform the transfer</span></div>
<div class="line"><a class="code" href="group__SPI__DRV__MasterDriver.html#ga98197b2cd6be2b2e161549d50d8e6250">SPI_DRV_MasterTransferBlocking</a>(masterInstance, NULL, s_spiSourceBuffer, s_spiSinkBuffer, 32, 1000);</div>
<div class="line"><span class="comment">// Do other transfers, when done with the SPI, then de-init to shut it down</span></div>
<div class="line"><a class="code" href="group__SPI__DRV__MasterDriver.html#ga0e7e44e45359ae45346485a2e38ff637">SPI_DRV_MasterDeinit</a>(instance);</div>
</div><!-- fragment --><p>Note that it is not normally recommended to mix interrupt and DMA-driven drivers in the same application. However, should the user decide to do so, they can separately set up and initialize another instance for DMA operations. The user can also de-init the current interrupt-driven SPI instance and re-initialize it for DMA operations. Note that since the DMA-driven driver also uses interrupts, the user must take care to direct the IRQ handler from the vector table to the desired driver's IRQ handler. Refer to files fsl_spi_irq.c and fsl_spi_dma_irq.c for examples on how to re-direct the IRQ handlers from the vector table to the interrupt-driven and DMA-driven driver IRQ handlers. Such files need to be included in the applications project in order to direct the SPI interrupt vectors to the proper IRQ handlers. There are also two other files, fsl_spi_shared_function.c and fsl_spi_dma_shared_function.c that direct the interrupts from the vector table to the appropriate master or slave driver interrupt handler by checking the SPI mode via the HAL function SPI_HAL_IsMaster(baseAddr). Note that the interrupt driver calls SPI_DRV_IRQHandler() and DMA driver calls SPI_DRV_DmaIRQHandler(). Refer to files fsl_spi_irq.c and fsl_spi_dma_irq.c for an example of these function calls.</p>
<h1><a class="anchor" id="SPIRtSS"></a>
SPI Run-time state structures</h1>
<p>The SPI master driver uses a run-time state structure to track the ongoing data transfers. The state structure for the interrupt-driven driver is called <a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__master__state__t" title="Runtime state of the SPI master driver. ">spi_master_state_t</a> while the state structure for the DMA-driven driver is called <a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__dma__master__state__t" title="Runtime state of the SPI master driver with DMA. ">spi_dma_master_state_t</a>. This structure holds data that the SPI master peripheral driver uses to communicate between the transfer function and the interrupt handler and other driver functions. The interrupt handler in the interrupt-driven driver also uses this information to keep track of its progress. The user is only required to pass the memory for the run-time state structure. The SPI master driver populates the members.</p>
<h1><a class="anchor" id="SPIdS"></a>
SPI Device structures</h1>
<p>The SPI master driver uses instances of the spi_device_t or spi_dma_device_t structure to represent the SPI bus configuration required to communicate to an external device that is connected to the bus.</p>
<p>The device structure can be passed into the SPI_DRV_MasterConfigureBus or SPI_DRV_DmaMasterConfigureBus functions to manually configure the bus for a particular device. For example, if there is only one device connected to the bus, the user might configure it only once. Alternatively the device structure can be passed to the data transfer functions where the bus is reconfigured before the transfer is started. The device structure consists of the following settings: bitsPerSec (baud rate in Hz), bit count (if the SPI module supports both 8- and 16-bit transfers), clock polarity and phase, and data shift direction (msb or lsb).</p>
<h1><a class="anchor" id="SPIInit"></a>
SPI Initialization</h1>
<p>To initialize the SPI master driver, call the <a class="el" href="group__SPI__DRV__MasterDriver.html#gac1f30c149f26ad5230b65b670a232e92" title="Initializes an SPI instance for master mode operation. ">SPI_DRV_MasterInit()</a> or <a class="el" href="group__SPI__DRV__MasterDriver.html#ga6aba990facfc0d2494c0b290dc42d6eb" title="Initializes a SPI instance for master mode operation to work with DMA. ">SPI_DRV_DmaMasterInit()</a> function and pass the instance number of the SPI peripheral you want to use. For example, to use the SPI1 module, pass a value 1 to the initialization function. In addition, the user also passes in the pointer to the run-time state structure used by the master driver to keep track of data transfers.</p>
<p>The user first calls the SPI master initialization to initialize the SPI module, then calls the SPI master configuration bus to configure the module for the specific device on the SPI bus. For the interrupt-driven case, while the <a class="el" href="group__SPI__DRV__MasterDriver.html#gac1f30c149f26ad5230b65b670a232e92" title="Initializes an SPI instance for master mode operation. ">SPI_DRV_MasterInit()</a> function initializes the SPI peripheral, the <a class="el" href="group__SPI__DRV__MasterDriver.html#ga0562675eefc63ce119738e9f11b7b55f" title="Configures the SPI port to access a device on the bus. ">SPI_DRV_MasterConfigureBus()</a> function configures the SPI bus parameters such as bits/frame, clock characteristics, data shift direction, and baud rate. The DMA-driven case follows the same logic (except that it uses the DMA API names) and both examples are provided below. First, the interrupt-driven example is provided followed by the DMA example.</p>
<p>Example code to initialize and configure the SPI master interrupt-driven driver including setting up the user configuration and device structures: </p>
<div class="fragment"><div class="line">    <span class="comment">// Set up and init the master  //</span></div>
<div class="line">    uint32_t calculatedBaudRate;</div>
<div class="line">    uint32_t masterInstance = 1;  <span class="comment">// example using SPI instance 1</span></div>
<div class="line">    <a class="code" href="group__SPI__DRV__MasterDriver.html#structspi__master__state__t">spi_master_state_t</a> spiMasterState; <span class="comment">// simply allocate memory for this</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// configure the members of the user config //</span></div>
<div class="line">    <a class="code" href="group__SPI__DRV__MasterDriver.html#structspi__master__user__config__t">spi_master_user_config_t</a> userConfig;</div>
<div class="line">    userConfig.<a class="code" href="group__SPI__DRV__MasterDriver.html#a160db09944ca32b443fd8decfb6e377a">polarity</a> = <a class="code" href="group__spi__hal.html#gga3e5a7cd043c9596779bc23b34cb3d1f9a0b33c8e75da2f2c6a2e821f94cc77f46">kSpiClockPolarity_ActiveHigh</a>;</div>
<div class="line">    userConfig.<a class="code" href="group__SPI__DRV__MasterDriver.html#a9b5646c7a2ffede95354810063cc209f">phase</a> = <a class="code" href="group__spi__hal.html#gga9ad313685ade497f5cbcb71c74a1b4dcaac180df70db6fa5463501e6b7a38a183">kSpiClockPhase_FirstEdge</a>;</div>
<div class="line">    userConfig.<a class="code" href="group__SPI__DRV__MasterDriver.html#a1a3d66e8f558007aa902bc987cbc0852">direction</a> = <a class="code" href="group__spi__hal.html#ggaa68518c16202382c2e1f1c7c66a9d53daefa27165c331b1503fd02a79099e8dfe">kSpiMsbFirst</a>;</div>
<div class="line">    userConfig.<a class="code" href="group__SPI__DRV__MasterDriver.html#a0225b9353739a19e065f46e578702b4c">bitsPerSec</a> = 5000;  <span class="comment">// 5KHz baud rate</span></div>
<div class="line"><span class="preprocessor">#if FSL_FEATURE_SPI_16BIT_TRANSFERS</span></div>
<div class="line"><span class="preprocessor"></span>    userConfig.bitCount= <a class="code" href="group__spi__hal.html#ggaa7bfe75c1f0ea3b349f19a3de19b24e4a58b5d3b706acf9ccf16d83b82ac53675">kSpi8BitMode</a>;  <span class="comment">// set only if SPI module supports bit count feature</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">// init the SPI module //</span></div>
<div class="line">    <a class="code" href="group__SPI__DRV__MasterDriver.html#gac1f30c149f26ad5230b65b670a232e92">SPI_DRV_MasterInit</a>(masterInstance, &amp;spiMasterState);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// configure the SPI bus //</span></div>
<div class="line">    <a class="code" href="group__SPI__DRV__MasterDriver.html#ga0562675eefc63ce119738e9f11b7b55f">SPI_DRV_MasterConfigureBus</a>(masterInstance, &amp;userConfig, &amp;calculatedBaudRate);</div>
</div><!-- fragment --><p>Example code to initialize and configure the SPI master DMA-driven driver including setting up the user configuration and device structures. Note that some SPI modules may not support DMA transfers and this is distinguished in the driver using the feature name "FSL_FEATURE_SPI_HAS_DMA_SUPPORT". </p>
<div class="fragment"><div class="line"><span class="preprocessor">#if FSL_FEATURE_SPI_HAS_DMA_SUPPORT</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">// First, need to init the DMA peripheral driver.</span></div>
<div class="line">    <span class="comment">// NOTE: THIS IS NOT PART OF THE SPI DRIVER. THIS PART INITIALIZES THE DMA DRIVER SO</span></div>
<div class="line">    <span class="comment">// THAT THE SPI DMA DRIVER CAN WORK!</span></div>
<div class="line">    <a class="code" href="group__dma__driver.html#structdma__state__t">dma_state_t</a> state;  <span class="comment">//  &lt;- The user simply allocates memory for this structure.</span></div>
<div class="line">    <a class="code" href="group__dma__driver.html#gaf1fd6fa8977c57401b6e9143248254a1">DMA_DRV_Init</a>(&amp;state);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set up and init the master  //</span></div>
<div class="line">    uint32_t calculatedBaudRate;</div>
<div class="line">    uint32_t masterInstance = 0;  <span class="comment">// example using SPI instance 0</span></div>
<div class="line">    <a class="code" href="group__SPI__DRV__MasterDriver.html#structspi__dma__master__state__t">spi_dma_master_state_t</a> spiDmaMasterState; <span class="comment">// simply allocate memory for this</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// configure the members of the user config //</span></div>
<div class="line">    <a class="code" href="group__SPI__DRV__MasterDriver.html#structspi__dma__master__user__config__t">spi_dma_master_user_config_t</a> userDmaConfig;</div>
<div class="line">    userDmaConfig.polarity = <a class="code" href="group__spi__hal.html#gga3e5a7cd043c9596779bc23b34cb3d1f9a0b33c8e75da2f2c6a2e821f94cc77f46">kSpiClockPolarity_ActiveHigh</a>;</div>
<div class="line">    userDmaConfig.phase = <a class="code" href="group__spi__hal.html#gga9ad313685ade497f5cbcb71c74a1b4dcaac180df70db6fa5463501e6b7a38a183">kSpiClockPhase_FirstEdge</a>;</div>
<div class="line">    userDmaConfig.direction = <a class="code" href="group__spi__hal.html#ggaa68518c16202382c2e1f1c7c66a9d53daefa27165c331b1503fd02a79099e8dfe">kSpiMsbFirst</a>;</div>
<div class="line">    userDmaConfig.<a class="code" href="group__SPI__DRV__MasterDriver.html#a6b4922d2f2f98028a1bd0f678a12397d">bitsPerSec</a> = 5000;  <span class="comment">// 5KHz baud rate</span></div>
<div class="line"><span class="preprocessor">#if FSL_FEATURE_SPI_16BIT_TRANSFERS</span></div>
<div class="line"><span class="preprocessor"></span>    userDmaConfig.bitCount= <a class="code" href="group__spi__hal.html#ggaa7bfe75c1f0ea3b349f19a3de19b24e4a58b5d3b706acf9ccf16d83b82ac53675">kSpi8BitMode</a>;  <span class="comment">// set only if SPI module supports bit count feature</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">// init the SPI module //</span></div>
<div class="line">    <a class="code" href="group__SPI__DRV__MasterDriver.html#ga6aba990facfc0d2494c0b290dc42d6eb">SPI_DRV_DmaMasterInit</a>(masterInstance, &amp;spiDmaMasterState);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// configure the SPI bus //</span></div>
<div class="line">    <a class="code" href="group__SPI__DRV__MasterDriver.html#gaf33971d477512788a925f6434321f1ef">SPI_DRV_DmaMasterConfigureBus</a>(masterInstance, &amp;userDmaConfig, &amp;calculatedBaudRate);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><h1><a class="anchor" id="SPITrnsfrs"></a>
SPI Transfers</h1>
<p>The driver supports two different modes to transfer data: blocking and non-blocking. The blocking transfer function waits until the transfer is complete before returning. A timeout parameter is passed into the blocking function. A non-blocking (async) function returns immediately after starting the transfer. It is the responsibility of the user to get the transfer status during the transfer to ascertain when the transfer is complete. As such, additional functions are provided to aid in non-blocking transfers: get transfer status and abort transfer.</p>
<p>Note that some SPI modules may not support DMA transfers.</p>
<p>Blocking transfer function APIs (interrupt and DMA-driven): </p>
<div class="fragment"><div class="line"><a class="code" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> <a class="code" href="group__SPI__DRV__MasterDriver.html#ga98197b2cd6be2b2e161549d50d8e6250">SPI_DRV_MasterTransferBlocking</a>(uint32_t instance,</div>
<div class="line">                                            <span class="keyword">const</span> <a class="code" href="group__SPI__DRV__MasterDriver.html#structspi__master__user__config__t">spi_master_user_config_t</a> * restrict device,</div>
<div class="line">                                            <span class="keyword">const</span> uint8_t * restrict sendBuffer,</div>
<div class="line">                                            uint8_t * restrict receiveBuffer,</div>
<div class="line">                                            <span class="keywordtype">size_t</span> transferByteCount,</div>
<div class="line">                                            uint32_t timeout);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> <a class="code" href="group__SPI__DRV__MasterDriver.html#ga762fe58f8788ad99d40825a0e97b38a3">SPI_DRV_DmaMasterTransferBlocking</a>(uint32_t instance,</div>
<div class="line">                                               <span class="keyword">const</span> <a class="code" href="group__SPI__DRV__MasterDriver.html#structspi__dma__master__user__config__t">spi_dma_master_user_config_t</a> * restrict device,</div>
<div class="line">                                               <span class="keyword">const</span> uint8_t * restrict sendBuffer,</div>
<div class="line">                                               uint8_t * restrict receiveBuffer,</div>
<div class="line">                                               <span class="keywordtype">size_t</span> transferByteCount,</div>
<div class="line">                                               uint32_t timeout);</div>
</div><!-- fragment --><p>Non-blocking function APIs and associated functions (interrupt and DMA-driven): </p>
<div class="fragment"><div class="line"><span class="comment">// interrupt-driven transfer function</span></div>
<div class="line"><a class="code" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> <a class="code" href="group__SPI__DRV__MasterDriver.html#gae0019ea26966b739eac76c5dc19cea92">SPI_DRV_MasterTransfer</a>(uint32_t instance,</div>
<div class="line">                                <span class="keyword">const</span> <a class="code" href="group__SPI__DRV__MasterDriver.html#structspi__master__user__config__t">spi_master_user_config_t</a> * restrict device,</div>
<div class="line">                                <span class="keyword">const</span> uint8_t * restrict sendBuffer,</div>
<div class="line">                                uint8_t * restrict receiveBuffer,</div>
<div class="line">                                <span class="keywordtype">size_t</span> transferByteCount);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Returns whether the previous transfer is completed (interrupt-driven )</span></div>
<div class="line"><a class="code" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> <a class="code" href="group__SPI__DRV__MasterDriver.html#ga9da12d9f561f8060d63a33010491ff8c">SPI_DRV_MasterGetTransferStatus</a>(uint32_t instance, uint32_t * bytesTransferred);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Terminates an asynchronous transfer early (interrupt-driven )</span></div>
<div class="line"><a class="code" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> <a class="code" href="group__SPI__DRV__MasterDriver.html#ga761f1f44413fd6a0b61250de28ed8c97">SPI_DRV_MasterAbortTransfer</a>(uint32_t instance);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// DMA-driven transfer function</span></div>
<div class="line"><a class="code" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> <a class="code" href="group__SPI__DRV__MasterDriver.html#ga8335dfa93929a0ea375722e9eae68478">SPI_DRV_DmaMasterTransfer</a>(uint32_t instance,</div>
<div class="line">                                       <span class="keyword">const</span> <a class="code" href="group__SPI__DRV__MasterDriver.html#structspi__dma__master__user__config__t">spi_dma_master_user_config_t</a> * restrict device,</div>
<div class="line">                                       <span class="keyword">const</span> uint8_t * restrict sendBuffer,</div>
<div class="line">                                       uint8_t * restrict receiveBuffer,</div>
<div class="line">                                       <span class="keywordtype">size_t</span> transferByteCount);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Returns whether the previous transfer is completed (DMA-driven)</span></div>
<div class="line"><a class="code" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> <a class="code" href="group__SPI__DRV__MasterDriver.html#gaea5ebb6803ca06154ecb166b11b737f2">SPI_DRV_DmaMasterGetTransferStatus</a>(uint32_t instance, uint32_t * bytesTransferred);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Terminates an asynchronous transfer early (DMA-driven)</span></div>
<div class="line"><a class="code" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> <a class="code" href="group__SPI__DRV__MasterDriver.html#ga544567beb5c4bbf4fc83cb46cc5dc38d">SPI_DRV_DmaMasterAbortTransfer</a>(uint32_t instance);</div>
</div><!-- fragment --><p>Example of a blocking transfer (interrupt and DMA-driven). Note, first need to initialize the peripheral driver. Refer to the Initialization section to perform this first before transferring. </p>
<div class="fragment"><div class="line"><span class="comment">// Example blocking transfer function call (interrupt)</span></div>
<div class="line"><span class="comment">// Note: providing another device structure is optional and for this example, we&#39;ll assume the call</span></div>
<div class="line"><span class="comment">// to the SPI_DRV_MasterConfigureBus was sufficient, so we&#39;ll pass in NULL for the device structure.</span></div>
<div class="line"><span class="comment">// Also, this example shows that we&#39;re transferring 32 bytes with a timeout of 1000us.</span></div>
<div class="line"><a class="code" href="group__SPI__DRV__MasterDriver.html#ga98197b2cd6be2b2e161549d50d8e6250">SPI_DRV_MasterTransferBlocking</a>(masterInstance, NULL, s_spiSourceBuffer, s_spiSinkBuffer, 32, 1000);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Example blocking transfer function call (DMA)</span></div>
<div class="line"><span class="comment">// Note: providing another device structure is optional and for this example, we&#39;ll assume the call</span></div>
<div class="line"><span class="comment">// to the SPI_DRV_DmaMasterConfigureBus was sufficient, so we&#39;ll pass in NULL for the device</span></div>
<div class="line"><span class="comment">// structure. Also, this example shows that we&#39;re transferring 32 bytes with a timeout of 1000us.</span></div>
<div class="line"><a class="code" href="group__SPI__DRV__MasterDriver.html#ga762fe58f8788ad99d40825a0e97b38a3">SPI_DRV_DmaMasterTransferBlocking</a>(masterInstance, NULL, s_spiSourceBuffer, s_spiSinkBuffer,</div>
<div class="line">                                  32, 1000);</div>
</div><!-- fragment --><p>Example of a non-blocking transfer (interrupt and DMA-driven). Note, first need to initialize the peripheral driver. Refer to the Initialization section to perform this first before transferring: </p>
<div class="fragment"><div class="line"><span class="comment">// Interrupt Example</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line">uint32_t bytesXfer;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Example non-blocking transfer function call</span></div>
<div class="line"><span class="comment">// Note: providing another device structure is optional and for this example, we&#39;ll assume the call</span></div>
<div class="line"><span class="comment">// to the SPI_DRV_MasterConfigureBus was sufficient, so we&#39;ll pass in NULL for the device structure.</span></div>
<div class="line"><span class="comment">// Also, this example shows that we&#39;re transferring 32 bytes.</span></div>
<div class="line"><a class="code" href="group__SPI__DRV__MasterDriver.html#gae0019ea26966b739eac76c5dc19cea92">SPI_DRV_MasterTransfer</a>(masterInstance, NULL, s_spiSourceBuffer, s_spiSinkBuffer, 32);</div>
<div class="line"></div>
<div class="line"><span class="comment">// For non-blocking/async transfers, need to check back to get transfer status, for example</span></div>
<div class="line"><span class="comment">// Where bytesXfer returns the number of bytes transferred</span></div>
<div class="line"><a class="code" href="group__SPI__DRV__MasterDriver.html#ga9da12d9f561f8060d63a33010491ff8c">SPI_DRV_MasterGetTransferStatus</a>(masterInstance, &amp;bytesXfer);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Additionally, if for some reason we need to terminate the on-going transfer:</span></div>
<div class="line"><a class="code" href="group__SPI__DRV__MasterDriver.html#ga761f1f44413fd6a0b61250de28ed8c97">SPI_DRV_MasterAbortTransfer</a>(masterInstance);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// DMA Example</span></div>
<div class="line"><span class="comment"></span><span class="comment">// Example non-blocking transfer function call</span></div>
<div class="line"><span class="comment">// Note: providing another device structure is optional and for this example, we&#39;ll assume the call</span></div>
<div class="line"><span class="comment">// to the SPI_DRV_DmaMasterConfigureBus was sufficient, so we&#39;ll pass in NULL for the device</span></div>
<div class="line"><span class="comment">// structure.  Also, this example shows that we&#39;re transferring 32 bytes.</span></div>
<div class="line"><a class="code" href="group__SPI__DRV__MasterDriver.html#ga8335dfa93929a0ea375722e9eae68478">SPI_DRV_DmaMasterTransfer</a>(masterInstance, NULL, s_spiSourceBuffer, s_spiSinkBuffer, 32);</div>
<div class="line"></div>
<div class="line"><span class="comment">// For non-blocking/async transfers, need to check back to get transfer status, for example</span></div>
<div class="line"><span class="comment">// Where bytesXfer returns the number of bytes transferred</span></div>
<div class="line"><a class="code" href="group__SPI__DRV__MasterDriver.html#gaea5ebb6803ca06154ecb166b11b737f2">SPI_DRV_DmaMasterGetTransferStatus</a>(masterInstance, &amp;bytesXfer);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Additionally, if for some reason we need to terminate the on-going transfer:</span></div>
<div class="line"><a class="code" href="group__SPI__DRV__MasterDriver.html#ga544567beb5c4bbf4fc83cb46cc5dc38d">SPI_DRV_DmaMasterAbortTransfer</a>(masterInstance);</div>
</div><!-- fragment --><h1><a class="anchor" id="SPIDeinit"></a>
SPI De-initialization</h1>
<p>To de-initialize and shut down the SPI module, call the function: </p>
<div class="fragment"><div class="line"><span class="comment">// interrupt-driven</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="group__SPI__DRV__MasterDriver.html#ga0e7e44e45359ae45346485a2e38ff637">SPI_DRV_MasterDeinit</a>(masterInstance);</div>
<div class="line"></div>
<div class="line"><span class="comment">// DMA-driven</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="group__SPI__DRV__MasterDriver.html#gad060c628f9d7d77ac5235f3f9f417f2a">SPI_DRV_DmaMasterDeinit</a>(masterInstance);</div>
</div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structspi__dma__master__user__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__dma__master__user__config__t">spi_dma_master_user_config_t</a></td></tr>
<tr class="memdesc:structspi__dma__master__user__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a device on the SPI bus with DMA.  <a href="group__SPI__DRV__MasterDriver.html#structspi__dma__master__user__config__t">More...</a><br/></td></tr>
<tr class="separator:structspi__dma__master__user__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structspi__dma__master__state__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__dma__master__state__t">spi_dma_master_state_t</a></td></tr>
<tr class="memdesc:structspi__dma__master__state__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime state of the SPI master driver with DMA.  <a href="group__SPI__DRV__MasterDriver.html#structspi__dma__master__state__t">More...</a><br/></td></tr>
<tr class="separator:structspi__dma__master__state__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structspi__master__user__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__master__user__config__t">spi_master_user_config_t</a></td></tr>
<tr class="memdesc:structspi__master__user__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a device on the SPI bus.  <a href="group__SPI__DRV__MasterDriver.html#structspi__master__user__config__t">More...</a><br/></td></tr>
<tr class="separator:structspi__master__user__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structspi__master__state__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__master__state__t">spi_master_state_t</a></td></tr>
<tr class="memdesc:structspi__master__state__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime state of the SPI master driver.  <a href="group__SPI__DRV__MasterDriver.html#structspi__master__state__t">More...</a><br/></td></tr>
<tr class="separator:structspi__master__state__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga613e0bda5978360535b501afc5a9fec7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#ga613e0bda5978360535b501afc5a9fec7">_spi_dma_timeouts</a> { <a class="el" href="group__SPI__DRV__MasterDriver.html#gga613e0bda5978360535b501afc5a9fec7ac3e78fad0d585d51fe23555df7dabe28">kSpiDmaWaitForever</a> = 0x7fffffff
 }</td></tr>
<tr class="separator:ga613e0bda5978360535b501afc5a9fec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga427122f80e42b2207809b5a89cc58131"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#ga427122f80e42b2207809b5a89cc58131">_spi_timeouts</a> { <a class="el" href="group__SPI__DRV__MasterDriver.html#gga427122f80e42b2207809b5a89cc58131a2bb5fb851db88e497ad03eff0ced1b6b">kSpiWaitForever</a> = 0x7fffffff
 }</td></tr>
<tr class="separator:ga427122f80e42b2207809b5a89cc58131"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga0456d58013e06bb298faa3a13a921d17"><td class="memItemLeft" align="right" valign="top">SPI_Type *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#ga0456d58013e06bb298faa3a13a921d17">g_spiBase</a> [SPI_INSTANCE_COUNT]</td></tr>
<tr class="memdesc:ga0456d58013e06bb298faa3a13a921d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of base pointers for SPI instances.  <a href="#ga0456d58013e06bb298faa3a13a921d17">More...</a><br/></td></tr>
<tr class="separator:ga0456d58013e06bb298faa3a13a921d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f7b62f63fbb61de81f98fd1042980f"><td class="memItemLeft" align="right" valign="top">const IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#gaf1f7b62f63fbb61de81f98fd1042980f">g_spiIrqId</a> [SPI_INSTANCE_COUNT]</td></tr>
<tr class="memdesc:gaf1f7b62f63fbb61de81f98fd1042980f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table to save SPI IRQ enumeration numbers defined in CMSIS header file.  <a href="#gaf1f7b62f63fbb61de81f98fd1042980f">More...</a><br/></td></tr>
<tr class="separator:gaf1f7b62f63fbb61de81f98fd1042980f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0456d58013e06bb298faa3a13a921d17"><td class="memItemLeft" align="right" valign="top">SPI_Type *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#ga0456d58013e06bb298faa3a13a921d17">g_spiBase</a> [SPI_INSTANCE_COUNT]</td></tr>
<tr class="memdesc:ga0456d58013e06bb298faa3a13a921d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of base pointers for SPI instances.  <a href="#ga0456d58013e06bb298faa3a13a921d17">More...</a><br/></td></tr>
<tr class="separator:ga0456d58013e06bb298faa3a13a921d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f7b62f63fbb61de81f98fd1042980f"><td class="memItemLeft" align="right" valign="top">const IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#gaf1f7b62f63fbb61de81f98fd1042980f">g_spiIrqId</a> [SPI_INSTANCE_COUNT]</td></tr>
<tr class="memdesc:gaf1f7b62f63fbb61de81f98fd1042980f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table to save SPI IRQ enumeration numbers defined in the CMSIS header file.  <a href="#gaf1f7b62f63fbb61de81f98fd1042980f">More...</a><br/></td></tr>
<tr class="separator:gaf1f7b62f63fbb61de81f98fd1042980f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Initialization and shutdown</h2></td></tr>
<tr class="memitem:ga6aba990facfc0d2494c0b290dc42d6eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#ga6aba990facfc0d2494c0b290dc42d6eb">SPI_DRV_DmaMasterInit</a> (uint32_t instance, <a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__dma__master__state__t">spi_dma_master_state_t</a> *spiDmaState)</td></tr>
<tr class="memdesc:ga6aba990facfc0d2494c0b290dc42d6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a SPI instance for master mode operation to work with DMA.  <a href="#ga6aba990facfc0d2494c0b290dc42d6eb">More...</a><br/></td></tr>
<tr class="separator:ga6aba990facfc0d2494c0b290dc42d6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad060c628f9d7d77ac5235f3f9f417f2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#gad060c628f9d7d77ac5235f3f9f417f2a">SPI_DRV_DmaMasterDeinit</a> (uint32_t instance)</td></tr>
<tr class="memdesc:gad060c628f9d7d77ac5235f3f9f417f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down a SPI instance with DMA support.  <a href="#gad060c628f9d7d77ac5235f3f9f417f2a">More...</a><br/></td></tr>
<tr class="separator:gad060c628f9d7d77ac5235f3f9f417f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Bus configuration</h2></td></tr>
<tr class="memitem:gaf33971d477512788a925f6434321f1ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#gaf33971d477512788a925f6434321f1ef">SPI_DRV_DmaMasterConfigureBus</a> (uint32_t instance, const <a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__dma__master__user__config__t">spi_dma_master_user_config_t</a> *device, uint32_t *calculatedBaudRate)</td></tr>
<tr class="memdesc:gaf33971d477512788a925f6434321f1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the SPI port to access a device on the bus with DMA support.  <a href="#gaf33971d477512788a925f6434321f1ef">More...</a><br/></td></tr>
<tr class="separator:gaf33971d477512788a925f6434321f1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Blocking transfers</h2></td></tr>
<tr class="memitem:ga762fe58f8788ad99d40825a0e97b38a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#ga762fe58f8788ad99d40825a0e97b38a3">SPI_DRV_DmaMasterTransferBlocking</a> (uint32_t instance, const <a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__dma__master__user__config__t">spi_dma_master_user_config_t</a> *device, const uint8_t *sendBuffer, uint8_t *receiveBuffer, size_t transferByteCount, uint32_t timeout)</td></tr>
<tr class="memdesc:ga762fe58f8788ad99d40825a0e97b38a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a blocking SPI master mode transfer with DMA support.  <a href="#ga762fe58f8788ad99d40825a0e97b38a3">More...</a><br/></td></tr>
<tr class="separator:ga762fe58f8788ad99d40825a0e97b38a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Non-blocking transfers</h2></td></tr>
<tr class="memitem:ga8335dfa93929a0ea375722e9eae68478"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#ga8335dfa93929a0ea375722e9eae68478">SPI_DRV_DmaMasterTransfer</a> (uint32_t instance, const <a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__dma__master__user__config__t">spi_dma_master_user_config_t</a> *device, const uint8_t *sendBuffer, uint8_t *receiveBuffer, size_t transferByteCount)</td></tr>
<tr class="memdesc:ga8335dfa93929a0ea375722e9eae68478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a non-blocking SPI master mode transfer with DMA support.  <a href="#ga8335dfa93929a0ea375722e9eae68478">More...</a><br/></td></tr>
<tr class="separator:ga8335dfa93929a0ea375722e9eae68478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5ebb6803ca06154ecb166b11b737f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#gaea5ebb6803ca06154ecb166b11b737f2">SPI_DRV_DmaMasterGetTransferStatus</a> (uint32_t instance, uint32_t *bytesTransferred)</td></tr>
<tr class="memdesc:gaea5ebb6803ca06154ecb166b11b737f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the previous transfer finished with DMA support.  <a href="#gaea5ebb6803ca06154ecb166b11b737f2">More...</a><br/></td></tr>
<tr class="separator:gaea5ebb6803ca06154ecb166b11b737f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga544567beb5c4bbf4fc83cb46cc5dc38d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#ga544567beb5c4bbf4fc83cb46cc5dc38d">SPI_DRV_DmaMasterAbortTransfer</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga544567beb5c4bbf4fc83cb46cc5dc38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates an asynchronous transfer early with DMA support.  <a href="#ga544567beb5c4bbf4fc83cb46cc5dc38d">More...</a><br/></td></tr>
<tr class="separator:ga544567beb5c4bbf4fc83cb46cc5dc38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0ab7c21bb8e5e16c9aa5477c25baa66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#gaa0ab7c21bb8e5e16c9aa5477c25baa66">SPI_DRV_DmaMasterIRQHandler</a> (uint32_t instance)</td></tr>
<tr class="memdesc:gaa0ab7c21bb8e5e16c9aa5477c25baa66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt handler for SPI master mode.  <a href="#gaa0ab7c21bb8e5e16c9aa5477c25baa66">More...</a><br/></td></tr>
<tr class="separator:gaa0ab7c21bb8e5e16c9aa5477c25baa66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Initialization and shutdown</h2></td></tr>
<tr class="memitem:gac1f30c149f26ad5230b65b670a232e92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#gac1f30c149f26ad5230b65b670a232e92">SPI_DRV_MasterInit</a> (uint32_t instance, <a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__master__state__t">spi_master_state_t</a> *spiState)</td></tr>
<tr class="memdesc:gac1f30c149f26ad5230b65b670a232e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an SPI instance for master mode operation.  <a href="#gac1f30c149f26ad5230b65b670a232e92">More...</a><br/></td></tr>
<tr class="separator:gac1f30c149f26ad5230b65b670a232e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e7e44e45359ae45346485a2e38ff637"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#ga0e7e44e45359ae45346485a2e38ff637">SPI_DRV_MasterDeinit</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga0e7e44e45359ae45346485a2e38ff637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down an SPI instance.  <a href="#ga0e7e44e45359ae45346485a2e38ff637">More...</a><br/></td></tr>
<tr class="separator:ga0e7e44e45359ae45346485a2e38ff637"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Bus configuration</h2></td></tr>
<tr class="memitem:ga0562675eefc63ce119738e9f11b7b55f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#ga0562675eefc63ce119738e9f11b7b55f">SPI_DRV_MasterConfigureBus</a> (uint32_t instance, const <a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__master__user__config__t">spi_master_user_config_t</a> *device, uint32_t *calculatedBaudRate)</td></tr>
<tr class="memdesc:ga0562675eefc63ce119738e9f11b7b55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the SPI port to access a device on the bus.  <a href="#ga0562675eefc63ce119738e9f11b7b55f">More...</a><br/></td></tr>
<tr class="separator:ga0562675eefc63ce119738e9f11b7b55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Blocking transfers</h2></td></tr>
<tr class="memitem:ga98197b2cd6be2b2e161549d50d8e6250"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#ga98197b2cd6be2b2e161549d50d8e6250">SPI_DRV_MasterTransferBlocking</a> (uint32_t instance, const <a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__master__user__config__t">spi_master_user_config_t</a> *device, const uint8_t *sendBuffer, uint8_t *receiveBuffer, size_t transferByteCount, uint32_t timeout)</td></tr>
<tr class="memdesc:ga98197b2cd6be2b2e161549d50d8e6250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a blocking SPI master mode transfer.  <a href="#ga98197b2cd6be2b2e161549d50d8e6250">More...</a><br/></td></tr>
<tr class="separator:ga98197b2cd6be2b2e161549d50d8e6250"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Non-blocking transfers</h2></td></tr>
<tr class="memitem:gae0019ea26966b739eac76c5dc19cea92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#gae0019ea26966b739eac76c5dc19cea92">SPI_DRV_MasterTransfer</a> (uint32_t instance, const <a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__master__user__config__t">spi_master_user_config_t</a> *device, const uint8_t *sendBuffer, uint8_t *receiveBuffer, size_t transferByteCount)</td></tr>
<tr class="memdesc:gae0019ea26966b739eac76c5dc19cea92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a non-blocking SPI master mode transfer.  <a href="#gae0019ea26966b739eac76c5dc19cea92">More...</a><br/></td></tr>
<tr class="separator:gae0019ea26966b739eac76c5dc19cea92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9da12d9f561f8060d63a33010491ff8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#ga9da12d9f561f8060d63a33010491ff8c">SPI_DRV_MasterGetTransferStatus</a> (uint32_t instance, uint32_t *bytesTransferred)</td></tr>
<tr class="memdesc:ga9da12d9f561f8060d63a33010491ff8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the previous transfer is completed.  <a href="#ga9da12d9f561f8060d63a33010491ff8c">More...</a><br/></td></tr>
<tr class="separator:ga9da12d9f561f8060d63a33010491ff8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga761f1f44413fd6a0b61250de28ed8c97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#ga761f1f44413fd6a0b61250de28ed8c97">SPI_DRV_MasterAbortTransfer</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga761f1f44413fd6a0b61250de28ed8c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates an asynchronous transfer early.  <a href="#ga761f1f44413fd6a0b61250de28ed8c97">More...</a><br/></td></tr>
<tr class="separator:ga761f1f44413fd6a0b61250de28ed8c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga368b24a0abf7640592a9a9e19c2933ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#ga368b24a0abf7640592a9a9e19c2933ac">SPI_DRV_MasterIRQHandler</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga368b24a0abf7640592a9a9e19c2933ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt handler for SPI master mode.  <a href="#ga368b24a0abf7640592a9a9e19c2933ac">More...</a><br/></td></tr>
<tr class="separator:ga368b24a0abf7640592a9a9e19c2933ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structspi__dma__master__user__config__t" id="structspi__dma__master__user__config__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spi_dma_master_user_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a6b4922d2f2f98028a1bd0f678a12397d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b4922d2f2f98028a1bd0f678a12397d"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a6b4922d2f2f98028a1bd0f678a12397d">bitsPerSec</a></td></tr>
<tr class="memdesc:a6b4922d2f2f98028a1bd0f678a12397d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI baud rate in bits per sec. <br/></td></tr>
<tr class="separator:a6b4922d2f2f98028a1bd0f678a12397d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="structspi__dma__master__state__t" id="structspi__dma__master__state__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spi_dma_master_state_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure holds data that are used by the SPI master peripheral driver to communicate between the transfer function and the interrupt handler. The interrupt handler also uses this information to keep track of its progress. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a002788a66573468867ebb07dfafaca8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a002788a66573468867ebb07dfafaca8f"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a002788a66573468867ebb07dfafaca8f">spiSourceClock</a></td></tr>
<tr class="memdesc:a002788a66573468867ebb07dfafaca8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module source clock. <br/></td></tr>
<tr class="separator:a002788a66573468867ebb07dfafaca8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dcaa7699d2399b0deef33596d1294f"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#ac8dcaa7699d2399b0deef33596d1294f">isTransferInProgress</a></td></tr>
<tr class="memdesc:ac8dcaa7699d2399b0deef33596d1294f"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if there is an active transfer.  <a href="#ac8dcaa7699d2399b0deef33596d1294f">More...</a><br/></td></tr>
<tr class="separator:ac8dcaa7699d2399b0deef33596d1294f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfa26528fb0ee71f5e376acd5066d53"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a0cfa26528fb0ee71f5e376acd5066d53">sendBuffer</a></td></tr>
<tr class="memdesc:a0cfa26528fb0ee71f5e376acd5066d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer being sent.  <a href="#a0cfa26528fb0ee71f5e376acd5066d53">More...</a><br/></td></tr>
<tr class="separator:a0cfa26528fb0ee71f5e376acd5066d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69213a344d590074475f13cdff8cf18"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#ad69213a344d590074475f13cdff8cf18">receiveBuffer</a></td></tr>
<tr class="memdesc:ad69213a344d590074475f13cdff8cf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer into which received bytes are placed.  <a href="#ad69213a344d590074475f13cdff8cf18">More...</a><br/></td></tr>
<tr class="separator:ad69213a344d590074475f13cdff8cf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab686301972730713d5e5bc6fecdfddc"><td class="memItemLeft" align="right" valign="top">volatile size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#aab686301972730713d5e5bc6fecdfddc">remainingSendByteCount</a></td></tr>
<tr class="memdesc:aab686301972730713d5e5bc6fecdfddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes remaining to send.  <a href="#aab686301972730713d5e5bc6fecdfddc">More...</a><br/></td></tr>
<tr class="separator:aab686301972730713d5e5bc6fecdfddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e893c9cd546ae3fac0319662930bdac"><td class="memItemLeft" align="right" valign="top">volatile size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a1e893c9cd546ae3fac0319662930bdac">remainingReceiveByteCount</a></td></tr>
<tr class="memdesc:a1e893c9cd546ae3fac0319662930bdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes remaining to receive.  <a href="#a1e893c9cd546ae3fac0319662930bdac">More...</a><br/></td></tr>
<tr class="separator:a1e893c9cd546ae3fac0319662930bdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabb64a9e3a874217b7d5a35b7729d16"><td class="memItemLeft" align="right" valign="top">volatile size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#aeabb64a9e3a874217b7d5a35b7729d16">transferredByteCount</a></td></tr>
<tr class="memdesc:aeabb64a9e3a874217b7d5a35b7729d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes transferred so far.  <a href="#aeabb64a9e3a874217b7d5a35b7729d16">More...</a><br/></td></tr>
<tr class="separator:aeabb64a9e3a874217b7d5a35b7729d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fa434509a4903b57f30feda8498c15"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a81fa434509a4903b57f30feda8498c15">isTransferBlocking</a></td></tr>
<tr class="memdesc:a81fa434509a4903b57f30feda8498c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if transfer is a blocking transaction.  <a href="#a81fa434509a4903b57f30feda8498c15">More...</a><br/></td></tr>
<tr class="separator:a81fa434509a4903b57f30feda8498c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590d2323dcbbf51067a8af02c0b23a00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__os__abstraction__bm.html#structsemaphore__t">semaphore_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a590d2323dcbbf51067a8af02c0b23a00">irqSync</a></td></tr>
<tr class="memdesc:a590d2323dcbbf51067a8af02c0b23a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to wait for ISR to complete its business.  <a href="#a590d2323dcbbf51067a8af02c0b23a00">More...</a><br/></td></tr>
<tr class="separator:a590d2323dcbbf51067a8af02c0b23a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477751d82e9c30ef6a8399929db05759"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a477751d82e9c30ef6a8399929db05759"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a477751d82e9c30ef6a8399929db05759">extraByte</a></td></tr>
<tr class="memdesc:a477751d82e9c30ef6a8399929db05759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag used for 16-bit transfers with odd byte count. <br/></td></tr>
<tr class="separator:a477751d82e9c30ef6a8399929db05759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a16213468a0c147d22ab3c1d51f6f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29a16213468a0c147d22ab3c1d51f6f4"></a>
<a class="el" href="group__dma__driver.html#structdma__channel__t">dma_channel_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a29a16213468a0c147d22ab3c1d51f6f4">dmaReceive</a></td></tr>
<tr class="memdesc:a29a16213468a0c147d22ab3c1d51f6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The DMA channel used for receive. <br/></td></tr>
<tr class="separator:a29a16213468a0c147d22ab3c1d51f6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b077d58b895bb7eb27e915a4cdbba9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86b077d58b895bb7eb27e915a4cdbba9"></a>
<a class="el" href="group__dma__driver.html#structdma__channel__t">dma_channel_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a86b077d58b895bb7eb27e915a4cdbba9">dmaTransmit</a></td></tr>
<tr class="memdesc:a86b077d58b895bb7eb27e915a4cdbba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The DMA channel used for transmit. <br/></td></tr>
<tr class="separator:a86b077d58b895bb7eb27e915a4cdbba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8285f7b88366c1b0861afdb8f0b87f89"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a8285f7b88366c1b0861afdb8f0b87f89">transferByteCnt</a></td></tr>
<tr class="memdesc:a8285f7b88366c1b0861afdb8f0b87f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes to transfer.  <a href="#a8285f7b88366c1b0861afdb8f0b87f89">More...</a><br/></td></tr>
<tr class="separator:a8285f7b88366c1b0861afdb8f0b87f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="ac8dcaa7699d2399b0deef33596d1294f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool spi_dma_master_state_t::isTransferInProgress</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0cfa26528fb0ee71f5e376acd5066d53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* spi_dma_master_state_t::sendBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad69213a344d590074475f13cdff8cf18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* spi_dma_master_state_t::receiveBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aab686301972730713d5e5bc6fecdfddc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile size_t spi_dma_master_state_t::remainingSendByteCount</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1e893c9cd546ae3fac0319662930bdac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile size_t spi_dma_master_state_t::remainingReceiveByteCount</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeabb64a9e3a874217b7d5a35b7729d16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile size_t spi_dma_master_state_t::transferredByteCount</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a81fa434509a4903b57f30feda8498c15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool spi_dma_master_state_t::isTransferBlocking</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a590d2323dcbbf51067a8af02c0b23a00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__os__abstraction__bm.html#structsemaphore__t">semaphore_t</a> spi_dma_master_state_t::irqSync</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8285f7b88366c1b0861afdb8f0b87f89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spi_dma_master_state_t::transferByteCnt</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structspi__master__user__config__t" id="structspi__master__user__config__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spi_master_user_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a0225b9353739a19e065f46e578702b4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0225b9353739a19e065f46e578702b4c"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a0225b9353739a19e065f46e578702b4c">bitsPerSec</a></td></tr>
<tr class="memdesc:a0225b9353739a19e065f46e578702b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI baud rate in bits per sec. <br/></td></tr>
<tr class="separator:a0225b9353739a19e065f46e578702b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160db09944ca32b443fd8decfb6e377a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a160db09944ca32b443fd8decfb6e377a"></a>
<a class="el" href="group__spi__hal.html#ga3e5a7cd043c9596779bc23b34cb3d1f9">spi_clock_polarity_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a160db09944ca32b443fd8decfb6e377a">polarity</a></td></tr>
<tr class="memdesc:a160db09944ca32b443fd8decfb6e377a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Active high or low clock polarity. <br/></td></tr>
<tr class="separator:a160db09944ca32b443fd8decfb6e377a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5646c7a2ffede95354810063cc209f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b5646c7a2ffede95354810063cc209f"></a>
<a class="el" href="group__spi__hal.html#ga9ad313685ade497f5cbcb71c74a1b4dc">spi_clock_phase_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a9b5646c7a2ffede95354810063cc209f">phase</a></td></tr>
<tr class="memdesc:a9b5646c7a2ffede95354810063cc209f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock phase setting to change and capture data. <br/></td></tr>
<tr class="separator:a9b5646c7a2ffede95354810063cc209f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3d66e8f558007aa902bc987cbc0852"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a3d66e8f558007aa902bc987cbc0852"></a>
<a class="el" href="group__spi__hal.html#gaa68518c16202382c2e1f1c7c66a9d53d">spi_shift_direction_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a1a3d66e8f558007aa902bc987cbc0852">direction</a></td></tr>
<tr class="memdesc:a1a3d66e8f558007aa902bc987cbc0852"><td class="mdescLeft">&#160;</td><td class="mdescRight">MSB or LSB data shift direction. <br/></td></tr>
<tr class="separator:a1a3d66e8f558007aa902bc987cbc0852"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="structspi__master__state__t" id="structspi__master__state__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spi_master_state_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure holds data that are used by the SPI master peripheral driver to communicate between the transfer function and the interrupt handler. The interrupt handler also uses this information to keep track of its progress. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a25f06abf267858975dd0d834f1b46f27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25f06abf267858975dd0d834f1b46f27"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a25f06abf267858975dd0d834f1b46f27">spiSourceClock</a></td></tr>
<tr class="memdesc:a25f06abf267858975dd0d834f1b46f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module source clock. <br/></td></tr>
<tr class="separator:a25f06abf267858975dd0d834f1b46f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccb9ab6ab323ffadf8d1c63ba512321"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#acccb9ab6ab323ffadf8d1c63ba512321">isTransferInProgress</a></td></tr>
<tr class="memdesc:acccb9ab6ab323ffadf8d1c63ba512321"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if there is an active transfer.  <a href="#acccb9ab6ab323ffadf8d1c63ba512321">More...</a><br/></td></tr>
<tr class="separator:acccb9ab6ab323ffadf8d1c63ba512321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa971c199b1c2555eea592ea8f449dba2"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#aa971c199b1c2555eea592ea8f449dba2">sendBuffer</a></td></tr>
<tr class="memdesc:aa971c199b1c2555eea592ea8f449dba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer being sent.  <a href="#aa971c199b1c2555eea592ea8f449dba2">More...</a><br/></td></tr>
<tr class="separator:aa971c199b1c2555eea592ea8f449dba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545d84bea0410209b386e88e9387953b"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a545d84bea0410209b386e88e9387953b">receiveBuffer</a></td></tr>
<tr class="memdesc:a545d84bea0410209b386e88e9387953b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer into which received bytes are placed.  <a href="#a545d84bea0410209b386e88e9387953b">More...</a><br/></td></tr>
<tr class="separator:a545d84bea0410209b386e88e9387953b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6534867a1855748f78c85142b5b892ee"><td class="memItemLeft" align="right" valign="top">volatile size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a6534867a1855748f78c85142b5b892ee">remainingSendByteCount</a></td></tr>
<tr class="memdesc:a6534867a1855748f78c85142b5b892ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes remaining to send.  <a href="#a6534867a1855748f78c85142b5b892ee">More...</a><br/></td></tr>
<tr class="separator:a6534867a1855748f78c85142b5b892ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebe7191c995db1f446d91e7d117b7c0"><td class="memItemLeft" align="right" valign="top">volatile size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a9ebe7191c995db1f446d91e7d117b7c0">remainingReceiveByteCount</a></td></tr>
<tr class="memdesc:a9ebe7191c995db1f446d91e7d117b7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes remaining to receive.  <a href="#a9ebe7191c995db1f446d91e7d117b7c0">More...</a><br/></td></tr>
<tr class="separator:a9ebe7191c995db1f446d91e7d117b7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0e78fe966afd57cc83f47c2c34424a"><td class="memItemLeft" align="right" valign="top">volatile size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#a7a0e78fe966afd57cc83f47c2c34424a">transferredByteCount</a></td></tr>
<tr class="memdesc:a7a0e78fe966afd57cc83f47c2c34424a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes transferred so far.  <a href="#a7a0e78fe966afd57cc83f47c2c34424a">More...</a><br/></td></tr>
<tr class="separator:a7a0e78fe966afd57cc83f47c2c34424a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20c9ca671defbfb3e5955f5ae99ed32"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#ad20c9ca671defbfb3e5955f5ae99ed32">isTransferBlocking</a></td></tr>
<tr class="memdesc:ad20c9ca671defbfb3e5955f5ae99ed32"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if transfer is a blocking transaction.  <a href="#ad20c9ca671defbfb3e5955f5ae99ed32">More...</a><br/></td></tr>
<tr class="separator:ad20c9ca671defbfb3e5955f5ae99ed32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4eed32d6e78cdbe1b1c70ba753dd04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__os__abstraction__bm.html#structsemaphore__t">semaphore_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#afa4eed32d6e78cdbe1b1c70ba753dd04">irqSync</a></td></tr>
<tr class="memdesc:afa4eed32d6e78cdbe1b1c70ba753dd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to wait for ISR to complete its business.  <a href="#afa4eed32d6e78cdbe1b1c70ba753dd04">More...</a><br/></td></tr>
<tr class="separator:afa4eed32d6e78cdbe1b1c70ba753dd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca875e1d8ccaa1c59585fb446f21a2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abca875e1d8ccaa1c59585fb446f21a2b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI__DRV__MasterDriver.html#abca875e1d8ccaa1c59585fb446f21a2b">extraByte</a></td></tr>
<tr class="memdesc:abca875e1d8ccaa1c59585fb446f21a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag used for 16-bit transfers with odd byte count. <br/></td></tr>
<tr class="separator:abca875e1d8ccaa1c59585fb446f21a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="acccb9ab6ab323ffadf8d1c63ba512321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool spi_master_state_t::isTransferInProgress</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa971c199b1c2555eea592ea8f449dba2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* spi_master_state_t::sendBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a545d84bea0410209b386e88e9387953b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* spi_master_state_t::receiveBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6534867a1855748f78c85142b5b892ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile size_t spi_master_state_t::remainingSendByteCount</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9ebe7191c995db1f446d91e7d117b7c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile size_t spi_master_state_t::remainingReceiveByteCount</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7a0e78fe966afd57cc83f47c2c34424a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile size_t spi_master_state_t::transferredByteCount</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad20c9ca671defbfb3e5955f5ae99ed32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool spi_master_state_t::isTransferBlocking</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afa4eed32d6e78cdbe1b1c70ba753dd04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__os__abstraction__bm.html#structsemaphore__t">semaphore_t</a> spi_master_state_t::irqSync</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga613e0bda5978360535b501afc5a9fec7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SPI__DRV__MasterDriver.html#ga613e0bda5978360535b501afc5a9fec7">_spi_dma_timeouts</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga613e0bda5978360535b501afc5a9fec7ac3e78fad0d585d51fe23555df7dabe28"></a>kSpiDmaWaitForever</em>&#160;</td><td class="fielddoc">
<p>Waits forever for a transfer to complete. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga427122f80e42b2207809b5a89cc58131"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SPI__DRV__MasterDriver.html#ga427122f80e42b2207809b5a89cc58131">_spi_timeouts</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga427122f80e42b2207809b5a89cc58131a2bb5fb851db88e497ad03eff0ced1b6b"></a>kSpiWaitForever</em>&#160;</td><td class="fielddoc">
<p>Waits forever for a transfer to complete. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6aba990facfc0d2494c0b290dc42d6eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_DmaMasterInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__dma__master__state__t">spi_dma_master_state_t</a> *&#160;</td>
          <td class="paramname"><em>spiDmaState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function uses a DMA-driven method for transferring data. This function initializes the run-time state structure to track the ongoing transfers, un-gates the clock to the SPI module, resets the SPI module, initializes the module to user defined settings and default settings, configures the IRQ state structure, enables the module-level interrupt to the core, and enables the SPI module.</p>
<p>This initialization function also configures the DMA module by requesting channels for DMA operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
    <tr><td class="paramname">spiDmaState</td><td>The pointer to the SPI DMA master driver state structure. The user must pass the memory for this run-time state structure and the SPI master driver fills out the members. This run-time state structure keeps track of the transfer in progress. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_SPI_Success indicating successful initialization </dd></dl>

</div>
</div>
<a class="anchor" id="gad060c628f9d7d77ac5235f3f9f417f2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_DmaMasterDeinit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function resets the SPI peripheral, gates its clock, disables any used interrupts to the core, and releases any used DMA channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_SPI_Success indicating successful de-initialization </dd></dl>

</div>
</div>
<a class="anchor" id="gaf33971d477512788a925f6434321f1ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPI_DRV_DmaMasterConfigureBus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__dma__master__user__config__t">spi_dma_master_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>calculatedBaudRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The term "device" is used to indicate the SPI device for which the SPI master is communicating. The user has two options to configure the device parameters: either pass in the pointer to the device configuration structure to the desired transfer function or pass it in to the SPI_DRV_DmaMasterConfigureBus function. The user can pass in a device structure to the transfer function which contains the parameters for the bus (the transfer function then calls this function). However, the user has the option to call this function directly especially to get the calculated baud rate, at which point they may pass in NULL for the device structure in the transfer function (assuming they have called this configure bus function first).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
    <tr><td class="paramname">device</td><td>Pointer to the device information structure. This structure contains the settings for SPI bus configurations. </td></tr>
    <tr><td class="paramname">calculatedBaudRate</td><td>The calculated baud rate passed back to the user to determine if the calculated baud rate is close enough to meet the needs. The baud rate never exceeds the desired baud rate unless the baud rate requested is less than the absolute minimum in which case the minimum baud rate will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga762fe58f8788ad99d40825a0e97b38a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_DmaMasterTransferBlocking </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__dma__master__user__config__t">spi_dma_master_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>sendBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>receiveBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>transferByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function simultaneously sends and receives data on the SPI bus, as SPI is naturally a full-duplex bus. The function does return until the transfer is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
    <tr><td class="paramname">device</td><td>Pointer to the device information structure. This structure contains the settings for the SPI bus configuration for this transfer. You may pass NULL for this parameter, in which case the current bus configuration is used unmodified. </td></tr>
    <tr><td class="paramname">sendBuffer</td><td>Buffer of data to send. You may pass NULL for this parameter, in which case bytes with a value of 0 (zero) are sent. </td></tr>
    <tr><td class="paramname">receiveBuffer</td><td>Buffer where received bytes are stored. If you pass NULL for this parameter, the received bytes are ignored. </td></tr>
    <tr><td class="paramname">transferByteCount</td><td>The number of bytes to send and receive. </td></tr>
    <tr><td class="paramname">timeout</td><td>A timeout for the transfer in microseconds. If the transfer takes longer than this amount of time, the transfer is aborted and a <a class="el" href="group__spi__hal.html#gga856ecadf3d7fe18c4fc3ae56500f8982a496ced6fffc33d7bbeb01d203dfc4836" title="SPI transfer timed out. ">kStatus_SPI_Timeout</a> error is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#kStatus_Success The transfer was successful. <a class="el" href="group__spi__hal.html#gga856ecadf3d7fe18c4fc3ae56500f8982a703abdf7900047c4d13536480f3463ab" title="SPI instance is already busy performing a transfer. ">kStatus_SPI_Busy</a> Cannot perform another transfer because one is already in progress. <a class="el" href="group__spi__hal.html#gga856ecadf3d7fe18c4fc3ae56500f8982a496ced6fffc33d7bbeb01d203dfc4836" title="SPI transfer timed out. ">kStatus_SPI_Timeout</a> The transfer timed out and was aborted. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8335dfa93929a0ea375722e9eae68478"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_DmaMasterTransfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__dma__master__user__config__t">spi_dma_master_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>sendBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>receiveBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>transferByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns immediately. It is the user's responsibility to check back to ascertain if the transfer is complete (using the SPI_DRV_DmaMasterGetTransferStatus function). This function simultaneously sends and receives data on the SPI bus, as SPI is naturally a full-duplex bus. The function does return until the transfer is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
    <tr><td class="paramname">device</td><td>Pointer to the device information structure. This structure contains the settings for the SPI bus configuration for this transfer. You may pass NULL for this parameter, in which case the current bus configuration is used unmodified. </td></tr>
    <tr><td class="paramname">sendBuffer</td><td>Buffer of data to send. You may pass NULL for this parameter, in which case bytes with a value of 0 (zero) is sent. </td></tr>
    <tr><td class="paramname">receiveBuffer</td><td>Buffer where received bytes are stored. If you pass NULL for this parameter, the received bytes are ignored. </td></tr>
    <tr><td class="paramname">transferByteCount</td><td>The number of bytes to send and receive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#kStatus_Success The transfer was successful. <a class="el" href="group__spi__hal.html#gga856ecadf3d7fe18c4fc3ae56500f8982a703abdf7900047c4d13536480f3463ab" title="SPI instance is already busy performing a transfer. ">kStatus_SPI_Busy</a> Cannot perform another transfer because one is already in progress. <a class="el" href="group__spi__hal.html#gga856ecadf3d7fe18c4fc3ae56500f8982a496ced6fffc33d7bbeb01d203dfc4836" title="SPI transfer timed out. ">kStatus_SPI_Timeout</a> The transfer timed out and was aborted. </dd></dl>

</div>
</div>
<a class="anchor" id="gaea5ebb6803ca06154ecb166b11b737f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_DmaMasterGetTransferStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bytesTransferred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When performing an a-sync transfer, the user can call this function to ascertain the state of the current transfer: in progress (or busy) or complete (success). In addition, if the transfer is still in progress, the user can get the number of words that have been transferred up to now.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
    <tr><td class="paramname">bytesTransferred</td><td>Pointer to a value that is filled in with the number of bytes that were sent in the active transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_Success The transfer has completed successfully. kStatus_SPI_Busy The transfer is still in progress. <em>bytesTransferred</em> is filled with the number of bytes that have been transferred so far. </dd></dl>

</div>
</div>
<a class="anchor" id="ga544567beb5c4bbf4fc83cb46cc5dc38d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_DmaMasterAbortTransfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>During an a-sync transfer, the user has the option to terminate the transfer early if the transfer is still in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_SPI_Success The transfer was successful. kStatus_SPI_NoTransferInProgress No transfer is currently in progress. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa0ab7c21bb8e5e16c9aa5477c25baa66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPI_DRV_DmaMasterIRQHandler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This handler is used when the extraByte flag is set to retrieve the received last byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac1f30c149f26ad5230b65b670a232e92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_MasterInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__master__state__t">spi_master_state_t</a> *&#160;</td>
          <td class="paramname"><em>spiState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function uses a CPU interrupt driven method for transferring data. It initializes the run-time state structure to track the ongoing transfers, un-gates the clock to the SPI module, resets and initializes the module to default settings, configures the IRQ state structure, enables the module-level interrupt to the core, and enables the SPI module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
    <tr><td class="paramname">spiState</td><td>The pointer to the SPI master driver state structure. The user passes the memory for the run-time state structure and the SPI master driver populates the members. This run-time state structure keeps track of the transfer in progress. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_SPI_Success indicating successful initialization </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e7e44e45359ae45346485a2e38ff637"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_MasterDeinit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function resets the SPI peripheral, gates its clock, and disables the interrupt to the core.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_SPI_Success indicating successful de-initialization </dd></dl>

</div>
</div>
<a class="anchor" id="ga0562675eefc63ce119738e9f11b7b55f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPI_DRV_MasterConfigureBus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__master__user__config__t">spi_master_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>calculatedBaudRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The term "device" is used to indicate the SPI device for which the SPI master is communicating. The user has two options to configure the device parameters: either pass in the pointer to the device configuration structure to the desired transfer function (see SPI_DRV_MasterTransferDataBlocking or SPI_DRV_MasterTransferData) or pass it in to the SPI_DRV_MasterConfigureBus function. The user can pass in a device structure to the transfer function which contains the parameters for the bus (the transfer function then calls this function). However, the user has the option to call this function directly especially to get the calculated baud rate, at which point they may pass in NULL for the device structure in the transfer function (assuming they have called this configure bus function first).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
    <tr><td class="paramname">device</td><td>Pointer to the device information structure. This structure contains the settings for SPI bus configurations. </td></tr>
    <tr><td class="paramname">calculatedBaudRate</td><td>The calculated baud rate passed back to the user to determine if the calculated baud rate is close enough to meet the needs. The baud rate never exceeds the desired baud rate unless the baud rate requested is less than the absolute minimum in which case the minimum baud rate is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98197b2cd6be2b2e161549d50d8e6250"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_MasterTransferBlocking </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__master__user__config__t">spi_master_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>sendBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>receiveBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>transferByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function simultaneously sends and receives data on the SPI bus, because the SPI is a full-duplex bus, and does not return until the transfer is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
    <tr><td class="paramname">device</td><td>Pointer to the device information structure. This structure contains the settings for the SPI bus configuration for this transfer. You may pass NULL for this parameter, in which case the current bus configuration is used unmodified. </td></tr>
    <tr><td class="paramname">sendBuffer</td><td>Buffer of data to send. You may pass NULL for this parameter, in which case bytes with a value of 0 (zero) are sent. </td></tr>
    <tr><td class="paramname">receiveBuffer</td><td>Buffer where received bytes are stored. If you pass NULL for this parameter, the received bytes are ignored. </td></tr>
    <tr><td class="paramname">transferByteCount</td><td>The number of bytes to send and receive. </td></tr>
    <tr><td class="paramname">timeout</td><td>A timeout for the transfer in microseconds. If the transfer takes longer than this amount of time, the transfer is aborted and a <a class="el" href="group__spi__hal.html#gga856ecadf3d7fe18c4fc3ae56500f8982a496ced6fffc33d7bbeb01d203dfc4836" title="SPI transfer timed out. ">kStatus_SPI_Timeout</a> error is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#kStatus_Success The transfer was successful. <a class="el" href="group__spi__hal.html#gga856ecadf3d7fe18c4fc3ae56500f8982a703abdf7900047c4d13536480f3463ab" title="SPI instance is already busy performing a transfer. ">kStatus_SPI_Busy</a> Cannot perform another transfer because one is already in progress. <a class="el" href="group__spi__hal.html#gga856ecadf3d7fe18c4fc3ae56500f8982a496ced6fffc33d7bbeb01d203dfc4836" title="SPI transfer timed out. ">kStatus_SPI_Timeout</a> The transfer timed out and was aborted. </dd></dl>

</div>
</div>
<a class="anchor" id="gae0019ea26966b739eac76c5dc19cea92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_MasterTransfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__master__user__config__t">spi_master_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>sendBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>receiveBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>transferByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns immediately. The user should check back to find out if the transfer is complete (using the SPI_DRV_MasterGetTransferStatus function). This function simultaneously sends and receives data on the SPI bus, because the SPI is a full-duplex bus, and does not return until the transfer is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
    <tr><td class="paramname">device</td><td>Pointer to the device information structure. This structure contains the settings for the SPI bus configuration for this transfer. You may pass NULL for this parameter, in which case the current bus configuration is used unmodified. </td></tr>
    <tr><td class="paramname">sendBuffer</td><td>Buffer of data to send. You may pass NULL for this parameter, in which case bytes with a value of 0 (zero) is sent. </td></tr>
    <tr><td class="paramname">receiveBuffer</td><td>Buffer where received bytes are stored. If you pass NULL for this parameter, the received bytes are ignored. </td></tr>
    <tr><td class="paramname">transferByteCount</td><td>The number of bytes to send and receive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#kStatus_Success The transfer was successful. <a class="el" href="group__spi__hal.html#gga856ecadf3d7fe18c4fc3ae56500f8982a703abdf7900047c4d13536480f3463ab" title="SPI instance is already busy performing a transfer. ">kStatus_SPI_Busy</a> Cannot perform another transfer because one is already in progress. <a class="el" href="group__spi__hal.html#gga856ecadf3d7fe18c4fc3ae56500f8982a496ced6fffc33d7bbeb01d203dfc4836" title="SPI transfer timed out. ">kStatus_SPI_Timeout</a> The transfer timed out and was aborted. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9da12d9f561f8060d63a33010491ff8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_MasterGetTransferStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bytesTransferred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When performing an a-sync transfer, calling this function shows the state of the current transfer: in progress (or busy) or complete (success). In addition, if the transfer is still in progress, the user can get the number of words that have been transferred up to now.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
    <tr><td class="paramname">bytesTransferred</td><td>Pointer to a value that is filled in with the number of bytes that were sent in the active transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_Success The transfer has completed successfully. kStatus_SPI_Busy The transfer is still in progress. <em>bytesTransferred</em> is filled with the number of bytes that have been transferred so far. </dd></dl>

</div>
</div>
<a class="anchor" id="ga761f1f44413fd6a0b61250de28ed8c97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_MasterAbortTransfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>During an a-sync transfer, the user has the option to terminate the transfer early if the transfer is still in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_SPI_Success The transfer was successful. kStatus_SPI_NoTransferInProgress No transfer is currently in progress. </dd></dl>

</div>
</div>
<a class="anchor" id="ga368b24a0abf7640592a9a9e19c2933ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPI_DRV_MasterIRQHandler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This handler uses the buffers stored in the <a class="el" href="group__SPI__DRV__MasterDriver.html#structspi__master__state__t" title="Runtime state of the SPI master driver. ">spi_master_state_t</a> structs to transfer data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga0456d58013e06bb298faa3a13a921d17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_Type* const g_spiBase[SPI_INSTANCE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf1f7b62f63fbb61de81f98fd1042980f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IRQn_Type g_spiIrqId[SPI_INSTANCE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0456d58013e06bb298faa3a13a921d17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_Type* const g_spiBase[SPI_INSTANCE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf1f7b62f63fbb61de81f98fd1042980f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IRQn_Type g_spiIrqId[SPI_INSTANCE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer">Thu Sep 24 2015 &copy; 2015 Freescale Semiconductor, Inc. All rights reserved.
    </li>
  </ul>
</div>
</body>
</html>
