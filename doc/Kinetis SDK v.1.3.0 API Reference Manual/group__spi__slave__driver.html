<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Kinetis SDK v.1.3 API Reference Manual: SPI Slave Peripheral Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fs_logo.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Kinetis SDK v.1.3 API Reference Manual
   &#160;<span id="projectnumber">Rev. 0</span>
   </div>
   <div id="projectbrief">Freescale Semiconductor, Inc.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__spi__slave__driver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">SPI Slave Peripheral Driver<div class="ingroups"><a class="el" href="group__spi.html">Serial Peripheral Interface (SPI)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p>This section describes the programming interface of the SPI slave mode peripheral driver.</p>
<h1><a class="anchor" id="SPIOvw"></a>
SPI Overview</h1>
<p>The SPI slave peripheral driver provides an easy way to use an SPI peripheral in slave mode. It supports transferring buffers of data with a single function call. When the SPI is configured for slave mode operations, it must first be set up to perform a transfer and then wait for the master to initiate the transfer. The driver is separated into two implementations: interrupt-driven and DMA-driven. The interrupt-driven driver uses interrupts to alert the CPU that the SPI module needs to service the SPI data transmit and receive operations. The DMA-driven driver uses the DMA module to transfer data between the buffers located in memory and the SPI module transmit/receive buffers/FIFOs. Note that some SPI modules may not support DMA transfers and this is distinguished in the driver using the feature name "FSL_FEATURE_SPI_HAS_DMA_SUPPORT". The interrupt-driven and DMA-driven driver APIs are distinguished by the keyword "dma" in the source file name and by the keyword "Dma" in the API name. Each set of drivers have the same API functionality and are described in the following sections. Note that the DMA-driven driver also uses interrupts to alert the CPU that the DMA has completed its transfer or that one final piece of data still needs to be received which is handled by the IRQ handler in the DMA-driven driver. In both the interrupt and DMA drivers, the SPI module interrupts are enabled in the NVIC. In addition, the DMA-driven driver requests channels from the DMA module. Also, subsequent sections refer to either set of drivers simply as the "SPI slave driver" when discussing items that pertain to either driver. Note, when using the DMA-driven SPI driver, initialize the DMA module. An example is shown later under the Initialization section. The following is a basic step-by-step overview of how to setup the SPI for SPI slave mode operations. For API specific examples, refer to the examples below. The following uses the interrupt-driven APIs and a blocking transfer to illustrate a high-level step-by-step usage. The usage of DMA driver is similar to interrupt-driven driver. Keep in mind that using interrupt and DMA drivers in the same runtime application is not normally recommended because the SPI interrupt handler needs to be changed. The interrupt driver calls SPI_DRV_IRQHandler() and DMA driver calls SPI_DRV_DmaIRQHandler(). Refer to files fsl_spi_irq.c and fsl_spi_dma_irq.c for an example of these function calls.</p>
<div class="fragment"><div class="line"><span class="comment">// Init the SPI</span></div>
<div class="line"><a class="code" href="group__spi__slave__driver.html#ga632e00d3812ed51b57a0054f10cac8c6">SPI_DRV_SlaveInit</a>(slaveInstance, &amp;spiSlaveState, &amp;userConfig);</div>
<div class="line"><span class="comment">// Perform the transfer (however, waits for master to initiate the transfer)</span></div>
<div class="line"><a class="code" href="group__spi__slave__driver.html#gab6ecb26a766c21d1a953f45377677e06">SPI_DRV_SlaveTransferBlocking</a>(slaveInstance, s_spiSourceBuffer, s_spiSinkBuffer, 32, 1000);</div>
<div class="line"><span class="comment">// Do other transfers, when done with the SPI, then de-init to shut it down</span></div>
<div class="line"><a class="code" href="group__spi__slave__driver.html#gaf62ec2a9e9c2dec1110a2b9da0c5f6df">SPI_DRV_SlaveDeinit</a>(instance);</div>
</div><!-- fragment --><p>Note that it is not normally recommended to mix interrupt and DMA-driven drivers in the same application. However, should the user decide to do so, they can separately set up and initialize another instance for DMA operations. The user can also de-init the current interrupt-driven SPI instance and re-initialize it for DMA operations. Note that since the DMA-driven driver also uses interrupts, the user must take care to direct the IRQ handler from the vector table to the desired driver's IRQ handler. Refer to files fsl_spi_irq.c and fsl_spi_dma_irq.c for examples on how to re-direct the IRQ handlers from the vector table to the interrupt-driven and DMA-driven driver IRQ handlers. Such files need to be included in the applications project in order to direct the SPI interrupt vectors to the proper IRQ handlers. There are also two other files, fsl_spi_shared_function.c and fsl_spi_dma_shared_function.c that direct the interrupts from the vector table to the appropriate master or slave driver interrupt handler by checking the SPI mode via the HAL function SPI_HAL_IsMaster(baseAddr).</p>
<h1><a class="anchor" id="SPIRtSPIS"></a>
SPI Runtime state of the SPI slave driver</h1>
<p>The SPI slave driver uses a run-time state structure to track the ongoing data transfers. The state structure for the interrupt-driven driver is called <a class="el" href="group__spi__slave__driver.html#structspi__slave__state__t" title="Runtime state of the SPI slave driver. ">spi_slave_state_t</a> while the state structure for the DMA-driven driver is called <a class="el" href="group__spi__slave__driver.html#structspi__dma__slave__state__t" title="Runtime state of the SPI slave driver. ">spi_dma_slave_state_t</a>. The structure holds data that the SPI slave peripheral driver uses to communicate between the transfer function and the interrupt handler and other driver functions. The interrupt handler also uses this information to keep track of its progress. The user is only responsible to pass the memory for this run-time state structure and the SPI slave driver fills out the members.</p>
<h1><a class="anchor" id="SPIUcs"></a>
SPI User configuration structures</h1>
<p>The SPI slave driver uses instances of the user configuration structure for the SPI slave driver. The user configuration structure for the interrupt-driven driver is called <a class="el" href="group__spi__slave__driver.html#structspi__slave__user__config__t" title="User configuration structure for the SPI slave driver. ">spi_slave_user_config_t</a> while the user configuration structure for the DMA-driven driver is called <a class="el" href="group__spi__slave__driver.html#structspi__dma__slave__user__config__t" title="User configuration structure for the SPI slave driver. ">spi_dma_slave_user_config_t</a>. For this reason, the user can configure the most common settings of the SPI peripheral with a single function call.</p>
<h1><a class="anchor" id="SPIStpP"></a>
SPI Setup and Initialization</h1>
<p>To initialize the SPI slave driver, first create and fill in a <a class="el" href="group__spi__slave__driver.html#structspi__slave__user__config__t" title="User configuration structure for the SPI slave driver. ">spi_slave_user_config_t</a> structure for the interrupt-driven driver or <a class="el" href="group__spi__slave__driver.html#structspi__dma__slave__user__config__t" title="User configuration structure for the SPI slave driver. ">spi_dma_slave_user_config_t</a> structure for the DMA-driven driver. This structure defines the data format settings for the SPI peripheral. The structure is not required after the driver is initialized and can be allocated on the stack. The user also must pass the memory for the run-time state structure. Note that some SPI modules may not support DMA transfers and this is distinguished in the driver using the feature name "FSL_FEATURE_SPI_HAS_DMA_SUPPORT".</p>
<p>This is an example code to initialize and configure the driver for interrupt and DMA operations: </p>
<div class="fragment"><div class="line">    <span class="comment">// declare which module instance you want to use</span></div>
<div class="line">    uint32_t instance = 1;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// interrupt-driven</span></div>
<div class="line">    <a class="code" href="group__spi__slave__driver.html#structspi__slave__state__t">spi_slave_state_t</a> spiSlaveState;</div>
<div class="line">    <span class="comment">// update configs</span></div>
<div class="line">    <a class="code" href="group__spi__slave__driver.html#structspi__slave__user__config__t">spi_slave_user_config_t</a> slaveUserConfig;</div>
<div class="line">    slaveUserConfig.<a class="code" href="group__spi__slave__driver.html#a817f018aa9558eb4b153682a6d15d1a2">direction</a> = <a class="code" href="group__spi__hal.html#ggaa68518c16202382c2e1f1c7c66a9d53daefa27165c331b1503fd02a79099e8dfe">kSpiMsbFirst</a>;</div>
<div class="line">    slaveUserConfig.<a class="code" href="group__spi__slave__driver.html#a5a82acc2f86bf8d78ce3a489ba720760">polarity</a> = <a class="code" href="group__spi__hal.html#gga3e5a7cd043c9596779bc23b34cb3d1f9a0b33c8e75da2f2c6a2e821f94cc77f46">kSpiClockPolarity_ActiveHigh</a>;</div>
<div class="line">    slaveUserConfig.<a class="code" href="group__spi__slave__driver.html#a421ac6406636a059ebbb874d8b25edb3">phase</a> = <a class="code" href="group__spi__hal.html#gga9ad313685ade497f5cbcb71c74a1b4dcaac180df70db6fa5463501e6b7a38a183">kSpiClockPhase_FirstEdge</a>;</div>
<div class="line">    slaveUserConfig.<a class="code" href="group__spi__slave__driver.html#aec2a7ba3794acb4c27c43b2954d50f48">dummyPattern</a> = <a class="code" href="group__spi__slave__driver.html#ga407ea5985481e0780f08c5662be902da">SPI_DEFAULT_DUMMY_PATTERN</a>;</div>
<div class="line"><span class="preprocessor">#if FSL_FEATURE_SPI_16BIT_TRANSFERS</span></div>
<div class="line"><span class="preprocessor"></span>    slaveUserConfig.bitCount = <a class="code" href="group__spi__hal.html#ggaa7bfe75c1f0ea3b349f19a3de19b24e4a58b5d3b706acf9ccf16d83b82ac53675">kSpi8BitMode</a>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">// init the slave (interrupt-driven)</span></div>
<div class="line">    <a class="code" href="group__spi__slave__driver.html#ga632e00d3812ed51b57a0054f10cac8c6">SPI_DRV_SlaveInit</a>(instance, &amp;spiSlaveState, &amp;slaveUserConfig);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#if FSL_FEATURE_SPI_HAS_DMA_SUPPORT</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">// DMA-driven</span></div>
<div class="line">    <span class="comment">// First set up the DMA peripheral</span></div>
<div class="line">    <a class="code" href="group__dma__driver.html#structdma__state__t">dma_state_t</a> state;  <span class="comment">//  &lt;- The user simply allocates memory for this structure.</span></div>
<div class="line">    <a class="code" href="group__dma__driver.html#gaf1fd6fa8977c57401b6e9143248254a1">DMA_DRV_Init</a>(&amp;state);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// DMA-driven</span></div>
<div class="line">    <a class="code" href="group__spi__slave__driver.html#structspi__dma__slave__state__t">spi_dma_slave_state_t</a> spiDmaSlaveState;</div>
<div class="line">    <span class="comment">// update configs</span></div>
<div class="line">    <a class="code" href="group__spi__slave__driver.html#structspi__dma__slave__user__config__t">spi_dma_slave_user_config_t</a> slaveDmaUserConfig;</div>
<div class="line">    slaveDmaUserConfig.<a class="code" href="group__spi__slave__driver.html#ab56b5a58f7968894dabd592056fd1a3a">direction</a> = <a class="code" href="group__spi__hal.html#ggaa68518c16202382c2e1f1c7c66a9d53daefa27165c331b1503fd02a79099e8dfe">kSpiMsbFirst</a>;</div>
<div class="line">    slaveDmaUserConfig.<a class="code" href="group__spi__slave__driver.html#a6fbe62f409ac9eb52d0cdec1f63638ca">polarity</a> = <a class="code" href="group__spi__hal.html#gga3e5a7cd043c9596779bc23b34cb3d1f9a0b33c8e75da2f2c6a2e821f94cc77f46">kSpiClockPolarity_ActiveHigh</a>;</div>
<div class="line">    slaveDmaUserConfig.<a class="code" href="group__spi__slave__driver.html#a06f87eac2133f1947b6b9f18a4932f05">phase</a> = <a class="code" href="group__spi__hal.html#gga9ad313685ade497f5cbcb71c74a1b4dcaac180df70db6fa5463501e6b7a38a183">kSpiClockPhase_FirstEdge</a>;</div>
<div class="line">    slaveDmaUserConfig.<a class="code" href="group__spi__slave__driver.html#a95a264f14f0e47cc01824fb51814ba7d">dummyPattern</a> = <a class="code" href="group__spi__slave__driver.html#ga407ea5985481e0780f08c5662be902da">SPI_DEFAULT_DUMMY_PATTERN</a>;</div>
<div class="line"><span class="preprocessor">#if FSL_FEATURE_SPI_16BIT_TRANSFERS</span></div>
<div class="line"><span class="preprocessor"></span>    slaveDmaUserConfig.bitCount = <a class="code" href="group__spi__hal.html#ggaa7bfe75c1f0ea3b349f19a3de19b24e4a58b5d3b706acf9ccf16d83b82ac53675">kSpi8BitMode</a>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">// init the slave (DMA-driven)</span></div>
<div class="line">    <a class="code" href="group__spi__slave__driver.html#gaa403d17da9be09b84e5a00d0cf86516e">SPI_DRV_DmaSlaveInit</a>(instance, &amp;spiDmaSlaveState, &amp;slaveDmaUserConfig);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><h1><a class="anchor" id="SPIBlckNonbclck"></a>
SPI Blocking and non-blocking</h1>
<p>The SPI slave driver has two types of transfer functions, blocking and non-blocking calls. With non-blocking calls, the user starts the transfer and then waits for event flags are set. kSpiTransferDone indicates the transmission and reception are done. With the blocking call, the function only returns after the related process is all done.</p>
<p>Hear is an example of blocking and non-blocking call (interrupt-driven) </p>
<div class="fragment"><div class="line"><a class="code" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> result;</div>
<div class="line"><span class="comment">// Blocking call example</span></div>
<div class="line">result = <a class="code" href="group__spi__slave__driver.html#gab6ecb26a766c21d1a953f45377677e06">SPI_DRV_SlaveTransferBlocking</a>(instance, <span class="comment">// number of SPI peripheral</span></div>
<div class="line">                                       sendBuffer,    <span class="comment">// pointer to transmit buffer, can be NULL</span></div>
<div class="line">                                       receiveBuffer,  <span class="comment">// pointer to receive buffer, can be NULL</span></div>
<div class="line">                                       transferSize,   <span class="comment">// size of receive and receive data</span></div>
<div class="line">                                       10000);         <span class="comment">// Time out after 10000ms</span></div>
<div class="line"><span class="comment">// Check the result to know that transferring sucess or not.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Non-blocking call example</span></div>
<div class="line">result = <a class="code" href="group__spi__slave__driver.html#ga6b403edde9f60af0b9bd16639aae32bc">SPI_DRV_SlaveTransfer</a>(instance, <span class="comment">// number of SPI peripheral</span></div>
<div class="line">                               sendBuffer,     <span class="comment">// pointer to transmit buffer, can be NULL</span></div>
<div class="line">                               receiveBuffer,  <span class="comment">// pointer to receive buffer, can be NULL</span></div>
<div class="line">                               transferSize);  <span class="comment">// size of receive and receive data</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Wait for transfer done</span></div>
<div class="line"><span class="keywordflow">while</span>(kStatus_SPI_Success != <a class="code" href="group__spi__slave__driver.html#ga942a195e13c80f7e4738a5f3ab7d246c">SPI_DRV_SlaveGetTransferStatus</a>(instance, NULL));</div>
<div class="line"><span class="comment">// Must check the value of osaStatus to know that transferring success or not.</span></div>
</div><!-- fragment --><p>Additionally, some SPI modules support DMA transfers. To use the SPI with DMA, see the following example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> result;</div>
<div class="line"><span class="comment">// Blocking call example</span></div>
<div class="line">result = <a class="code" href="group__spi__slave__driver.html#ga0c4e6d6be2aba53b4625578ebb644a8e">SPI_DRV_DmaSlaveTransferBlocking</a>(instance, <span class="comment">// number of SPI peripheral</span></div>
<div class="line">                                        sendBuffer, <span class="comment">// pointer to transmit buffer, can be NULL</span></div>
<div class="line">                                        receiveBuffer, <span class="comment">// pointer to receive buffer, can be NULL</span></div>
<div class="line">                                        transferSize,   <span class="comment">// size of receive and receive data</span></div>
<div class="line">                                        10000);         <span class="comment">// Time out after 10000ms</span></div>
<div class="line"><span class="comment">// Check the result to know that transferring sucess or not.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Non-blocking call example</span></div>
<div class="line">result = <a class="code" href="group__spi__slave__driver.html#gac22206bfa01c886b52539929e08ba2a1">SPI_DRV_DmaSlaveTransfer</a>(instance, <span class="comment">// number of SPI peripheral</span></div>
<div class="line">                                  sendBuffer,     <span class="comment">// pointer to transmit buffer, can be NULL</span></div>
<div class="line">                                  receiveBuffer,  <span class="comment">// pointer to receive buffer, can be NULL</span></div>
<div class="line">                                  transferSize);  <span class="comment">// size of receive and receive data</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Wait for transfer done</span></div>
<div class="line"><span class="keywordflow">while</span>(kStatus_SPI_Success != <a class="code" href="group__spi__slave__driver.html#ga0bd4ef295e07f373a11eaeda896c9d7f">SPI_DRV_DmaSlaveGetTransferStatus</a>(instance, NULL));</div>
<div class="line"><span class="comment">// Must check the value of osaStatus to know that transferring success or not.</span></div>
</div><!-- fragment --><h1><a class="anchor" id="SPIDeinit"></a>
SPI De-initialization</h1>
<p>To de-initialize and shut down the SPI module, call the function: </p>
<div class="fragment"><div class="line"><span class="comment">// interrupt-driven</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="group__spi__slave__driver.html#gaf62ec2a9e9c2dec1110a2b9da0c5f6df">SPI_DRV_SlaveDeinit</a>(masterInstance);</div>
<div class="line"></div>
<div class="line"><span class="comment">// DMA-driven</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="group__spi__slave__driver.html#gaa01e84887ca79c3a7314fb4bee96a76b">SPI_DRV_DmaSlaveDeinit</a>(masterInstance);</div>
</div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structspi__dma__slave__user__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#structspi__dma__slave__user__config__t">spi_dma_slave_user_config_t</a></td></tr>
<tr class="memdesc:structspi__dma__slave__user__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">User configuration structure for the SPI slave driver.  <a href="group__spi__slave__driver.html#structspi__dma__slave__user__config__t">More...</a><br/></td></tr>
<tr class="separator:structspi__dma__slave__user__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structspi__dma__slave__state__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#structspi__dma__slave__state__t">spi_dma_slave_state_t</a></td></tr>
<tr class="memdesc:structspi__dma__slave__state__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime state of the SPI slave driver.  <a href="group__spi__slave__driver.html#structspi__dma__slave__state__t">More...</a><br/></td></tr>
<tr class="separator:structspi__dma__slave__state__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structspi__slave__user__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#structspi__slave__user__config__t">spi_slave_user_config_t</a></td></tr>
<tr class="memdesc:structspi__slave__user__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">User configuration structure for the SPI slave driver.  <a href="group__spi__slave__driver.html#structspi__slave__user__config__t">More...</a><br/></td></tr>
<tr class="separator:structspi__slave__user__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structspi__slave__state__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#structspi__slave__state__t">spi_slave_state_t</a></td></tr>
<tr class="memdesc:structspi__slave__state__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime state of the SPI slave driver.  <a href="group__spi__slave__driver.html#structspi__slave__state__t">More...</a><br/></td></tr>
<tr class="separator:structspi__slave__state__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga0226365a190b80ec9db3c393374b61c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0226365a190b80ec9db3c393374b61c4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ga0226365a190b80ec9db3c393374b61c4">SPI_DMA_DEFAULT_DUMMY_PATTERN</a>&#160;&#160;&#160;(0x0U)</td></tr>
<tr class="memdesc:ga0226365a190b80ec9db3c393374b61c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy pattern, that SPI slave sends when transmit data was not configured. <br/></td></tr>
<tr class="separator:ga0226365a190b80ec9db3c393374b61c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga407ea5985481e0780f08c5662be902da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga407ea5985481e0780f08c5662be902da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ga407ea5985481e0780f08c5662be902da">SPI_DEFAULT_DUMMY_PATTERN</a>&#160;&#160;&#160;(0x0U)</td></tr>
<tr class="memdesc:ga407ea5985481e0780f08c5662be902da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy pattern, that SPI slave sends when transmit data was not configured. <br/></td></tr>
<tr class="separator:ga407ea5985481e0780f08c5662be902da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga0456d58013e06bb298faa3a13a921d17"><td class="memItemLeft" align="right" valign="top">SPI_Type *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ga0456d58013e06bb298faa3a13a921d17">g_spiBase</a> [SPI_INSTANCE_COUNT]</td></tr>
<tr class="memdesc:ga0456d58013e06bb298faa3a13a921d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of base pointers for SPI instances.  <a href="#ga0456d58013e06bb298faa3a13a921d17">More...</a><br/></td></tr>
<tr class="separator:ga0456d58013e06bb298faa3a13a921d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f7b62f63fbb61de81f98fd1042980f"><td class="memItemLeft" align="right" valign="top">const IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#gaf1f7b62f63fbb61de81f98fd1042980f">g_spiIrqId</a> [SPI_INSTANCE_COUNT]</td></tr>
<tr class="memdesc:gaf1f7b62f63fbb61de81f98fd1042980f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table to save SPI IRQ enumeration numbers defined in CMSIS header file.  <a href="#gaf1f7b62f63fbb61de81f98fd1042980f">More...</a><br/></td></tr>
<tr class="separator:gaf1f7b62f63fbb61de81f98fd1042980f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0456d58013e06bb298faa3a13a921d17"><td class="memItemLeft" align="right" valign="top">SPI_Type *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ga0456d58013e06bb298faa3a13a921d17">g_spiBase</a> [SPI_INSTANCE_COUNT]</td></tr>
<tr class="memdesc:ga0456d58013e06bb298faa3a13a921d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of base pointers for SPI instances.  <a href="#ga0456d58013e06bb298faa3a13a921d17">More...</a><br/></td></tr>
<tr class="separator:ga0456d58013e06bb298faa3a13a921d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f7b62f63fbb61de81f98fd1042980f"><td class="memItemLeft" align="right" valign="top">const IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#gaf1f7b62f63fbb61de81f98fd1042980f">g_spiIrqId</a> [SPI_INSTANCE_COUNT]</td></tr>
<tr class="memdesc:gaf1f7b62f63fbb61de81f98fd1042980f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table to save SPI IRQ enumeration numbers defined in the CMSIS header file.  <a href="#gaf1f7b62f63fbb61de81f98fd1042980f">More...</a><br/></td></tr>
<tr class="separator:gaf1f7b62f63fbb61de81f98fd1042980f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Initialization and shutdown</h2></td></tr>
<tr class="memitem:gaa403d17da9be09b84e5a00d0cf86516e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#gaa403d17da9be09b84e5a00d0cf86516e">SPI_DRV_DmaSlaveInit</a> (uint32_t instance, <a class="el" href="group__spi__slave__driver.html#structspi__dma__slave__state__t">spi_dma_slave_state_t</a> *spiState, const <a class="el" href="group__spi__slave__driver.html#structspi__dma__slave__user__config__t">spi_dma_slave_user_config_t</a> *slaveConfig)</td></tr>
<tr class="memdesc:gaa403d17da9be09b84e5a00d0cf86516e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a SPI instance for a slave mode operation, using interrupt mechanism.  <a href="#gaa403d17da9be09b84e5a00d0cf86516e">More...</a><br/></td></tr>
<tr class="separator:gaa403d17da9be09b84e5a00d0cf86516e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa01e84887ca79c3a7314fb4bee96a76b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#gaa01e84887ca79c3a7314fb4bee96a76b">SPI_DRV_DmaSlaveDeinit</a> (uint32_t instance)</td></tr>
<tr class="memdesc:gaa01e84887ca79c3a7314fb4bee96a76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down a SPI instance - interrupt mechanism.  <a href="#gaa01e84887ca79c3a7314fb4bee96a76b">More...</a><br/></td></tr>
<tr class="separator:gaa01e84887ca79c3a7314fb4bee96a76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Blocking transfers</h2></td></tr>
<tr class="memitem:ga0c4e6d6be2aba53b4625578ebb644a8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ga0c4e6d6be2aba53b4625578ebb644a8e">SPI_DRV_DmaSlaveTransferBlocking</a> (uint32_t instance, const uint8_t *sendBuffer, uint8_t *receiveBuffer, uint32_t transferByteCount, uint32_t timeout)</td></tr>
<tr class="memdesc:ga0c4e6d6be2aba53b4625578ebb644a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers data on SPI bus using interrupt and blocking call.  <a href="#ga0c4e6d6be2aba53b4625578ebb644a8e">More...</a><br/></td></tr>
<tr class="separator:ga0c4e6d6be2aba53b4625578ebb644a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Non-blocking transfers</h2></td></tr>
<tr class="memitem:gac22206bfa01c886b52539929e08ba2a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#gac22206bfa01c886b52539929e08ba2a1">SPI_DRV_DmaSlaveTransfer</a> (uint32_t instance, const uint8_t *sendBuffer, uint8_t *receiveBuffer, uint32_t transferByteCount)</td></tr>
<tr class="memdesc:gac22206bfa01c886b52539929e08ba2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts transfer data on the SPI bus using an interrupt and a non-blocking call.  <a href="#gac22206bfa01c886b52539929e08ba2a1">More...</a><br/></td></tr>
<tr class="separator:gac22206bfa01c886b52539929e08ba2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e5f1b9867a240131daa3de85f41d4e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ga1e5f1b9867a240131daa3de85f41d4e5">SPI_DRV_DmaSlaveAbortTransfer</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga1e5f1b9867a240131daa3de85f41d4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the transfer that started by a non-blocking call transfer function.  <a href="#ga1e5f1b9867a240131daa3de85f41d4e5">More...</a><br/></td></tr>
<tr class="separator:ga1e5f1b9867a240131daa3de85f41d4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bd4ef295e07f373a11eaeda896c9d7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ga0bd4ef295e07f373a11eaeda896c9d7f">SPI_DRV_DmaSlaveGetTransferStatus</a> (uint32_t instance, uint32_t *framesTransferred)</td></tr>
<tr class="memdesc:ga0bd4ef295e07f373a11eaeda896c9d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the previous transfer is finished.  <a href="#ga0bd4ef295e07f373a11eaeda896c9d7f">More...</a><br/></td></tr>
<tr class="separator:ga0bd4ef295e07f373a11eaeda896c9d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65a7aa1a840a4a7a31d4beb7761c4dab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ga65a7aa1a840a4a7a31d4beb7761c4dab">SPI_DRV_DmaSlaveIRQHandler</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga65a7aa1a840a4a7a31d4beb7761c4dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt handler for SPI slave mode.  <a href="#ga65a7aa1a840a4a7a31d4beb7761c4dab">More...</a><br/></td></tr>
<tr class="separator:ga65a7aa1a840a4a7a31d4beb7761c4dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Initialization and shutdown</h2></td></tr>
<tr class="memitem:ga632e00d3812ed51b57a0054f10cac8c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ga632e00d3812ed51b57a0054f10cac8c6">SPI_DRV_SlaveInit</a> (uint32_t instance, <a class="el" href="group__spi__slave__driver.html#structspi__slave__state__t">spi_slave_state_t</a> *spiState, const <a class="el" href="group__spi__slave__driver.html#structspi__slave__user__config__t">spi_slave_user_config_t</a> *slaveConfig)</td></tr>
<tr class="memdesc:ga632e00d3812ed51b57a0054f10cac8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a SPI instance for a slave mode operation, using interrupt mechanism.  <a href="#ga632e00d3812ed51b57a0054f10cac8c6">More...</a><br/></td></tr>
<tr class="separator:ga632e00d3812ed51b57a0054f10cac8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf62ec2a9e9c2dec1110a2b9da0c5f6df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#gaf62ec2a9e9c2dec1110a2b9da0c5f6df">SPI_DRV_SlaveDeinit</a> (uint32_t instance)</td></tr>
<tr class="memdesc:gaf62ec2a9e9c2dec1110a2b9da0c5f6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down an SPI instance interrupt mechanism.  <a href="#gaf62ec2a9e9c2dec1110a2b9da0c5f6df">More...</a><br/></td></tr>
<tr class="separator:gaf62ec2a9e9c2dec1110a2b9da0c5f6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Blocking transfers</h2></td></tr>
<tr class="memitem:gab6ecb26a766c21d1a953f45377677e06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#gab6ecb26a766c21d1a953f45377677e06">SPI_DRV_SlaveTransferBlocking</a> (uint32_t instance, const uint8_t *sendBuffer, uint8_t *receiveBuffer, uint32_t transferByteCount, uint32_t timeout)</td></tr>
<tr class="memdesc:gab6ecb26a766c21d1a953f45377677e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers data on SPI bus using interrupt and a blocking call.  <a href="#gab6ecb26a766c21d1a953f45377677e06">More...</a><br/></td></tr>
<tr class="separator:gab6ecb26a766c21d1a953f45377677e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Non-blocking transfers</h2></td></tr>
<tr class="memitem:ga6b403edde9f60af0b9bd16639aae32bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ga6b403edde9f60af0b9bd16639aae32bc">SPI_DRV_SlaveTransfer</a> (uint32_t instance, const uint8_t *sendBuffer, uint8_t *receiveBuffer, uint32_t transferByteCount)</td></tr>
<tr class="memdesc:ga6b403edde9f60af0b9bd16639aae32bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the transfer data on SPI bus using an interrupt and a non-blocking call.  <a href="#ga6b403edde9f60af0b9bd16639aae32bc">More...</a><br/></td></tr>
<tr class="separator:ga6b403edde9f60af0b9bd16639aae32bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b194593011b75cb62ed78f6aaeb8774"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ga2b194593011b75cb62ed78f6aaeb8774">SPI_DRV_SlaveAbortTransfer</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga2b194593011b75cb62ed78f6aaeb8774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the transfer that started by a non-blocking call transfer function.  <a href="#ga2b194593011b75cb62ed78f6aaeb8774">More...</a><br/></td></tr>
<tr class="separator:ga2b194593011b75cb62ed78f6aaeb8774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga942a195e13c80f7e4738a5f3ab7d246c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ga942a195e13c80f7e4738a5f3ab7d246c">SPI_DRV_SlaveGetTransferStatus</a> (uint32_t instance, uint32_t *framesTransferred)</td></tr>
<tr class="memdesc:ga942a195e13c80f7e4738a5f3ab7d246c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the previous transfer is finished.  <a href="#ga942a195e13c80f7e4738a5f3ab7d246c">More...</a><br/></td></tr>
<tr class="separator:ga942a195e13c80f7e4738a5f3ab7d246c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484943d1ff5370777788dee055f6fa49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ga484943d1ff5370777788dee055f6fa49">SPI_DRV_SlaveIRQHandler</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga484943d1ff5370777788dee055f6fa49"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI Slave Generic IRQ handler.  <a href="#ga484943d1ff5370777788dee055f6fa49">More...</a><br/></td></tr>
<tr class="separator:ga484943d1ff5370777788dee055f6fa49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structspi__dma__slave__user__config__t" id="structspi__dma__slave__user__config__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spi_dma_slave_user_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a06f87eac2133f1947b6b9f18a4932f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga9ad313685ade497f5cbcb71c74a1b4dc">spi_clock_phase_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a06f87eac2133f1947b6b9f18a4932f05">phase</a></td></tr>
<tr class="memdesc:a06f87eac2133f1947b6b9f18a4932f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock phase setting.  <a href="#a06f87eac2133f1947b6b9f18a4932f05">More...</a><br/></td></tr>
<tr class="separator:a06f87eac2133f1947b6b9f18a4932f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbe62f409ac9eb52d0cdec1f63638ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#ga3e5a7cd043c9596779bc23b34cb3d1f9">spi_clock_polarity_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a6fbe62f409ac9eb52d0cdec1f63638ca">polarity</a></td></tr>
<tr class="memdesc:a6fbe62f409ac9eb52d0cdec1f63638ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock polarity setting.  <a href="#a6fbe62f409ac9eb52d0cdec1f63638ca">More...</a><br/></td></tr>
<tr class="separator:a6fbe62f409ac9eb52d0cdec1f63638ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56b5a58f7968894dabd592056fd1a3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__spi__hal.html#gaa68518c16202382c2e1f1c7c66a9d53d">spi_shift_direction_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ab56b5a58f7968894dabd592056fd1a3a">direction</a></td></tr>
<tr class="memdesc:ab56b5a58f7968894dabd592056fd1a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either LSB or MSB first.  <a href="#ab56b5a58f7968894dabd592056fd1a3a">More...</a><br/></td></tr>
<tr class="separator:ab56b5a58f7968894dabd592056fd1a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a264f14f0e47cc01824fb51814ba7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95a264f14f0e47cc01824fb51814ba7d"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a95a264f14f0e47cc01824fb51814ba7d">dummyPattern</a></td></tr>
<tr class="memdesc:a95a264f14f0e47cc01824fb51814ba7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy data value. <br/></td></tr>
<tr class="separator:a95a264f14f0e47cc01824fb51814ba7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a06f87eac2133f1947b6b9f18a4932f05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga9ad313685ade497f5cbcb71c74a1b4dc">spi_clock_phase_t</a> spi_dma_slave_user_config_t::phase</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6fbe62f409ac9eb52d0cdec1f63638ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga3e5a7cd043c9596779bc23b34cb3d1f9">spi_clock_polarity_t</a> spi_dma_slave_user_config_t::polarity</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab56b5a58f7968894dabd592056fd1a3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#gaa68518c16202382c2e1f1c7c66a9d53d">spi_shift_direction_t</a> spi_dma_slave_user_config_t::direction</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structspi__dma__slave__state__t" id="structspi__dma__slave__state__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spi_dma_slave_state_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure holds data that is used by the SPI slave peripheral driver to communicate between the transfer function and the interrupt handler. The user needs to pass in the memory for this structure and the driver fills out the members. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a5566ec4e4096f2f4175685a4fce671ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5566ec4e4096f2f4175685a4fce671ae"></a>
<a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a5566ec4e4096f2f4175685a4fce671ae">status</a></td></tr>
<tr class="memdesc:a5566ec4e4096f2f4175685a4fce671ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current state of slave. <br/></td></tr>
<tr class="separator:a5566ec4e4096f2f4175685a4fce671ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9a68f3cc1f5cd860a1e30f63bd15f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a9a68f3cc1f5cd860a1e30f63bd15f9"></a>
<a class="el" href="group__os__abstraction__bm.html#structevent__t">event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a2a9a68f3cc1f5cd860a1e30f63bd15f9">event</a></td></tr>
<tr class="memdesc:a2a9a68f3cc1f5cd860a1e30f63bd15f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event to notify waiting task. <br/></td></tr>
<tr class="separator:a2a9a68f3cc1f5cd860a1e30f63bd15f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af997cd127eda802a28cbc4bfef9fb1b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af997cd127eda802a28cbc4bfef9fb1b8"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#af997cd127eda802a28cbc4bfef9fb1b8">errorCount</a></td></tr>
<tr class="memdesc:af997cd127eda802a28cbc4bfef9fb1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver error count. <br/></td></tr>
<tr class="separator:af997cd127eda802a28cbc4bfef9fb1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a0485eec4cdc804b696a0576d3d763"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33a0485eec4cdc804b696a0576d3d763"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a33a0485eec4cdc804b696a0576d3d763">dummyPattern</a></td></tr>
<tr class="memdesc:a33a0485eec4cdc804b696a0576d3d763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy data is sent when there is no data in the transmit buffer. <br/></td></tr>
<tr class="separator:a33a0485eec4cdc804b696a0576d3d763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e02b98d5015060db626faab404de29f"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a1e02b98d5015060db626faab404de29f">isTransferInProgress</a></td></tr>
<tr class="memdesc:a1e02b98d5015060db626faab404de29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if there is an active transfer.  <a href="#a1e02b98d5015060db626faab404de29f">More...</a><br/></td></tr>
<tr class="separator:a1e02b98d5015060db626faab404de29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe86e619d94e1aebaf6d6aea2bd59a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfe86e619d94e1aebaf6d6aea2bd59a6"></a>
const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#acfe86e619d94e1aebaf6d6aea2bd59a6">sendBuffer</a></td></tr>
<tr class="memdesc:acfe86e619d94e1aebaf6d6aea2bd59a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to transmit buffer. <br/></td></tr>
<tr class="separator:acfe86e619d94e1aebaf6d6aea2bd59a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64682ebd3a21a273aaa10b83db6956a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64682ebd3a21a273aaa10b83db6956a1"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a64682ebd3a21a273aaa10b83db6956a1">receiveBuffer</a></td></tr>
<tr class="memdesc:a64682ebd3a21a273aaa10b83db6956a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to receive buffer. <br/></td></tr>
<tr class="separator:a64682ebd3a21a273aaa10b83db6956a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710a845e2fc53e6ac68d742038e9c718"><td class="memItemLeft" align="right" valign="top">volatile int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a710a845e2fc53e6ac68d742038e9c718">remainingSendByteCount</a></td></tr>
<tr class="memdesc:a710a845e2fc53e6ac68d742038e9c718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes remaining to send.  <a href="#a710a845e2fc53e6ac68d742038e9c718">More...</a><br/></td></tr>
<tr class="separator:a710a845e2fc53e6ac68d742038e9c718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374e1d9224ae051f147dd78d504c3d11"><td class="memItemLeft" align="right" valign="top">volatile int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a374e1d9224ae051f147dd78d504c3d11">remainingReceiveByteCount</a></td></tr>
<tr class="memdesc:a374e1d9224ae051f147dd78d504c3d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes remaining to receive.  <a href="#a374e1d9224ae051f147dd78d504c3d11">More...</a><br/></td></tr>
<tr class="separator:a374e1d9224ae051f147dd78d504c3d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3563309e584807a580f5b69d85bfcf9"><td class="memItemLeft" align="right" valign="top">volatile int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ad3563309e584807a580f5b69d85bfcf9">transferredByteCount</a></td></tr>
<tr class="memdesc:ad3563309e584807a580f5b69d85bfcf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes transferred so far.  <a href="#ad3563309e584807a580f5b69d85bfcf9">More...</a><br/></td></tr>
<tr class="separator:ad3563309e584807a580f5b69d85bfcf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f855a73437d701e699346858c027de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94f855a73437d701e699346858c027de"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a94f855a73437d701e699346858c027de">isSync</a></td></tr>
<tr class="memdesc:a94f855a73437d701e699346858c027de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the function call is sync or a-sync. <br/></td></tr>
<tr class="separator:a94f855a73437d701e699346858c027de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac795ebaee5cd614c054932fac64a7c4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac795ebaee5cd614c054932fac64a7c4b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ac795ebaee5cd614c054932fac64a7c4b">hasExtraByte</a></td></tr>
<tr class="memdesc:ac795ebaee5cd614c054932fac64a7c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the reception has extra byte. <br/></td></tr>
<tr class="separator:ac795ebaee5cd614c054932fac64a7c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a36fd6041cc35565ec6f13b5d2a6e27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a36fd6041cc35565ec6f13b5d2a6e27"></a>
<a class="el" href="group__dma__driver.html#structdma__channel__t">dma_channel_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a3a36fd6041cc35565ec6f13b5d2a6e27">dmaReceive</a></td></tr>
<tr class="memdesc:a3a36fd6041cc35565ec6f13b5d2a6e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">The DMA channel used for receive. <br/></td></tr>
<tr class="separator:a3a36fd6041cc35565ec6f13b5d2a6e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cf3b1df45f0aca4a03af4a089a547c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54cf3b1df45f0aca4a03af4a089a547c"></a>
<a class="el" href="group__dma__driver.html#structdma__channel__t">dma_channel_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a54cf3b1df45f0aca4a03af4a089a547c">dmaTransmit</a></td></tr>
<tr class="memdesc:a54cf3b1df45f0aca4a03af4a089a547c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The DMA channel used for transmit. <br/></td></tr>
<tr class="separator:a54cf3b1df45f0aca4a03af4a089a547c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a1e02b98d5015060db626faab404de29f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool spi_dma_slave_state_t::isTransferInProgress</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a710a845e2fc53e6ac68d742038e9c718"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile int32_t spi_dma_slave_state_t::remainingSendByteCount</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a374e1d9224ae051f147dd78d504c3d11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile int32_t spi_dma_slave_state_t::remainingReceiveByteCount</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad3563309e584807a580f5b69d85bfcf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile int32_t spi_dma_slave_state_t::transferredByteCount</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structspi__slave__user__config__t" id="structspi__slave__user__config__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spi_slave_user_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a421ac6406636a059ebbb874d8b25edb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a421ac6406636a059ebbb874d8b25edb3"></a>
<a class="el" href="group__spi__hal.html#ga9ad313685ade497f5cbcb71c74a1b4dc">spi_clock_phase_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a421ac6406636a059ebbb874d8b25edb3">phase</a></td></tr>
<tr class="memdesc:a421ac6406636a059ebbb874d8b25edb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock phase setting. <br/></td></tr>
<tr class="separator:a421ac6406636a059ebbb874d8b25edb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a82acc2f86bf8d78ce3a489ba720760"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a82acc2f86bf8d78ce3a489ba720760"></a>
<a class="el" href="group__spi__hal.html#ga3e5a7cd043c9596779bc23b34cb3d1f9">spi_clock_polarity_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a5a82acc2f86bf8d78ce3a489ba720760">polarity</a></td></tr>
<tr class="memdesc:a5a82acc2f86bf8d78ce3a489ba720760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock polarity setting. <br/></td></tr>
<tr class="separator:a5a82acc2f86bf8d78ce3a489ba720760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817f018aa9558eb4b153682a6d15d1a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a817f018aa9558eb4b153682a6d15d1a2"></a>
<a class="el" href="group__spi__hal.html#gaa68518c16202382c2e1f1c7c66a9d53d">spi_shift_direction_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a817f018aa9558eb4b153682a6d15d1a2">direction</a></td></tr>
<tr class="memdesc:a817f018aa9558eb4b153682a6d15d1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either LSB or MSB first. <br/></td></tr>
<tr class="separator:a817f018aa9558eb4b153682a6d15d1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2a7ba3794acb4c27c43b2954d50f48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec2a7ba3794acb4c27c43b2954d50f48"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#aec2a7ba3794acb4c27c43b2954d50f48">dummyPattern</a></td></tr>
<tr class="memdesc:aec2a7ba3794acb4c27c43b2954d50f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy data value. <br/></td></tr>
<tr class="separator:aec2a7ba3794acb4c27c43b2954d50f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="structspi__slave__state__t" id="structspi__slave__state__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spi_slave_state_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure holds data that is used by the SPI slave peripheral driver to communicate between the transfer function and the interrupt handler. The user needs to pass in the memory for this structure and the driver fills out the members. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:ade93797eee77af45021b73a46ffb4191"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade93797eee77af45021b73a46ffb4191"></a>
<a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ade93797eee77af45021b73a46ffb4191">status</a></td></tr>
<tr class="memdesc:ade93797eee77af45021b73a46ffb4191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current state of slave. <br/></td></tr>
<tr class="separator:ade93797eee77af45021b73a46ffb4191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89be19f25a4ba8bc47f11bd03f0993fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89be19f25a4ba8bc47f11bd03f0993fb"></a>
<a class="el" href="group__os__abstraction__bm.html#structevent__t">event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a89be19f25a4ba8bc47f11bd03f0993fb">event</a></td></tr>
<tr class="memdesc:a89be19f25a4ba8bc47f11bd03f0993fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event to notify waiting task. <br/></td></tr>
<tr class="separator:a89be19f25a4ba8bc47f11bd03f0993fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8a6ce42b7d35ce6fe58a0f718603a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d8a6ce42b7d35ce6fe58a0f718603a9"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a7d8a6ce42b7d35ce6fe58a0f718603a9">errorCount</a></td></tr>
<tr class="memdesc:a7d8a6ce42b7d35ce6fe58a0f718603a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver error count. <br/></td></tr>
<tr class="separator:a7d8a6ce42b7d35ce6fe58a0f718603a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5db2d1196cacc27038f34a0e12c072"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f5db2d1196cacc27038f34a0e12c072"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a2f5db2d1196cacc27038f34a0e12c072">dummyPattern</a></td></tr>
<tr class="memdesc:a2f5db2d1196cacc27038f34a0e12c072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy data is sent when there is no data in the transmit buffer. <br/></td></tr>
<tr class="separator:a2f5db2d1196cacc27038f34a0e12c072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad82c99e0775a49f87c6efc7ccaf663"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a5ad82c99e0775a49f87c6efc7ccaf663">isTransferInProgress</a></td></tr>
<tr class="memdesc:a5ad82c99e0775a49f87c6efc7ccaf663"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if there is an active transfer.  <a href="#a5ad82c99e0775a49f87c6efc7ccaf663">More...</a><br/></td></tr>
<tr class="separator:a5ad82c99e0775a49f87c6efc7ccaf663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79cca065bbfa6975705e4ef171e4836"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac79cca065bbfa6975705e4ef171e4836"></a>
const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#ac79cca065bbfa6975705e4ef171e4836">sendBuffer</a></td></tr>
<tr class="memdesc:ac79cca065bbfa6975705e4ef171e4836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to transmit buffer. <br/></td></tr>
<tr class="separator:ac79cca065bbfa6975705e4ef171e4836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443fe9d818dd4eee113dfa31b2c4fc90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a443fe9d818dd4eee113dfa31b2c4fc90"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a443fe9d818dd4eee113dfa31b2c4fc90">receiveBuffer</a></td></tr>
<tr class="memdesc:a443fe9d818dd4eee113dfa31b2c4fc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to receive buffer. <br/></td></tr>
<tr class="separator:a443fe9d818dd4eee113dfa31b2c4fc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478a36d08c78bd168fb28fb29abd58bd"><td class="memItemLeft" align="right" valign="top">volatile int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a478a36d08c78bd168fb28fb29abd58bd">remainingSendByteCount</a></td></tr>
<tr class="memdesc:a478a36d08c78bd168fb28fb29abd58bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes remaining to send.  <a href="#a478a36d08c78bd168fb28fb29abd58bd">More...</a><br/></td></tr>
<tr class="separator:a478a36d08c78bd168fb28fb29abd58bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1c6f716a58aefc9b60a5f967c4c948"><td class="memItemLeft" align="right" valign="top">volatile int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a4d1c6f716a58aefc9b60a5f967c4c948">remainingReceiveByteCount</a></td></tr>
<tr class="memdesc:a4d1c6f716a58aefc9b60a5f967c4c948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes remaining to receive.  <a href="#a4d1c6f716a58aefc9b60a5f967c4c948">More...</a><br/></td></tr>
<tr class="separator:a4d1c6f716a58aefc9b60a5f967c4c948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8204f778d24de7b28eed34075f47ea86"><td class="memItemLeft" align="right" valign="top">volatile int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a8204f778d24de7b28eed34075f47ea86">transferredByteCount</a></td></tr>
<tr class="memdesc:a8204f778d24de7b28eed34075f47ea86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes transferred so far.  <a href="#a8204f778d24de7b28eed34075f47ea86">More...</a><br/></td></tr>
<tr class="separator:a8204f778d24de7b28eed34075f47ea86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361a640266e72afc64ea5a8ef9ad1a10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a361a640266e72afc64ea5a8ef9ad1a10"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__slave__driver.html#a361a640266e72afc64ea5a8ef9ad1a10">isSync</a></td></tr>
<tr class="memdesc:a361a640266e72afc64ea5a8ef9ad1a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the function call is sync or a-sync. <br/></td></tr>
<tr class="separator:a361a640266e72afc64ea5a8ef9ad1a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a5ad82c99e0775a49f87c6efc7ccaf663"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool spi_slave_state_t::isTransferInProgress</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a478a36d08c78bd168fb28fb29abd58bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile int32_t spi_slave_state_t::remainingSendByteCount</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d1c6f716a58aefc9b60a5f967c4c948"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile int32_t spi_slave_state_t::remainingReceiveByteCount</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8204f778d24de7b28eed34075f47ea86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile int32_t spi_slave_state_t::transferredByteCount</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa403d17da9be09b84e5a00d0cf86516e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_DmaSlaveInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__spi__slave__driver.html#structspi__dma__slave__state__t">spi_dma_slave_state_t</a> *&#160;</td>
          <td class="paramname"><em>spiState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__spi__slave__driver.html#structspi__dma__slave__user__config__t">spi_dma_slave_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>slaveConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function un-gates the clock to the SPI module, initializes the SPI for slave mode. Once initialized, the SPI module is configured in slave mode and user can start transmit, receive data by calls send, receive, transfer functions. This function indicates SPI slave uses an interrupt mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
    <tr><td class="paramname">spiState</td><td>The pointer to the SPI slave driver state structure. </td></tr>
    <tr><td class="paramname">slaveConfig</td><td>The configuration structure <a class="el" href="group__spi__slave__driver.html#structspi__slave__user__config__t" title="User configuration structure for the SPI slave driver. ">spi_slave_user_config_t</a> which configures the data bus format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kStatus_SPI_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa01e84887ca79c3a7314fb4bee96a76b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_DmaSlaveDeinit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the SPI module, gates its clock, change SPI slave driver state to NonInit for SPI slave module which is initialized with interrupt mechanism. After de-initialized, user can re-initialize SPI slave module with other mechanisms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_SPI_Success indicating successful de-initialization </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c4e6d6be2aba53b4625578ebb644a8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_DmaSlaveTransferBlocking </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>sendBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>receiveBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>transferByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function check driver status, mechanism and transmit/receive data through SPI bus. If sendBuffer is NULL, transmit process is ignored. If the receiveBuffer is NULL, the receive process is ignored. If both the receiveBuffer and the sendBuffer are available, the transmit and the receive progress are processed. If only the receiveBuffer available, the receive is processed. Otherwise, the transmit is processed. This function returns when its processes are completed. This function uses interrupt mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of SPI peripheral </td></tr>
    <tr><td class="paramname">sendBuffer</td><td>The pointer to data that user wants to transmit. </td></tr>
    <tr><td class="paramname">receiveBuffer</td><td>The pointer to data that user wants to store received data. </td></tr>
    <tr><td class="paramname">transferByteCount</td><td>The number of bytes to send and receive. </td></tr>
    <tr><td class="paramname">timeout</td><td>The maximum number of milliseconds that function waits before timed out reached.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_SPI_Success if driver starts to send/receive data successfully. kStatus_SPI_Error if driver is error and needs to clean error. kStatus_SPI_Busy if driver is receiving/transmitting data and not available. kStatus_SPI_Timeout if time out reached while transferring is in progress. </dd></dl>

</div>
</div>
<a class="anchor" id="gac22206bfa01c886b52539929e08ba2a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_DmaSlaveTransfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>sendBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>receiveBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>transferByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function checks the driver status then set buffer pointers to receive and transmit SPI data. If the sendBuffer is NULL, the transmit process is ignored. If the receiveBuffer is NULL, the receive process is ignored. If both the receiveBuffer and the sendBuffer available, transfer is done when the kDspiTxDone and kDspiRxDone are set. If only the receiveBuffer is available, the transfer is done when the kDspiRxDone flag is set. Otherwise, the transfer is done when the kDspiTxDone was set. This function uses an interrupt mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of SPI peripheral </td></tr>
    <tr><td class="paramname">sendBuffer</td><td>The pointer to data that user wants to transmit. </td></tr>
    <tr><td class="paramname">receiveBuffer</td><td>The pointer to data that user wants to store received data. </td></tr>
    <tr><td class="paramname">transferByteCount</td><td>The number of bytes to send and receive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_SPI_Success if driver starts to send/receive data successfully. kStatus_SPI_Error if driver is error and needs to clean error. kStatus_SPI_Busy if driver is receiving/transmitting data and not available. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1e5f1b9867a240131daa3de85f41d4e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_DmaSlaveAbortTransfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function stops the transfer which was started by the <a class="el" href="group__spi__slave__driver.html#ga6b403edde9f60af0b9bd16639aae32bc" title="Starts the transfer data on SPI bus using an interrupt and a non-blocking call. ">SPI_DRV_SlaveTransfer()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of SPI peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_SPI_Success if everything is OK. kStatus_SPI_InvalidMechanism if the current transaction does not use interrupt mechanism. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0bd4ef295e07f373a11eaeda896c9d7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_DmaSlaveGetTransferStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>framesTransferred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When performing an a-sync transfer, the user can call this function to ascertain the state of the current transfer: in progress (or busy) or complete (success). In addition, if the transfer is still in progress, the user can get the number of words that have been transferred up to now.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
    <tr><td class="paramname">framesTransferred</td><td>Pointer to value that is filled in with the number of frames that have been sent in the active transfer. A frame is defined as the number of bits per frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_SPI_Success The transfer has completed successfully, or kStatus_SPI_Busy The transfer is still in progress. framesTransferred is filled with the number of words that have been transferred so far. </dd></dl>

</div>
</div>
<a class="anchor" id="ga65a7aa1a840a4a7a31d4beb7761c4dab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPI_DRV_DmaSlaveIRQHandler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This handler is used when the hasExtraByte flag is set to retrieve the received last byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga632e00d3812ed51b57a0054f10cac8c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_SlaveInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__spi__slave__driver.html#structspi__slave__state__t">spi_slave_state_t</a> *&#160;</td>
          <td class="paramname"><em>spiState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__spi__slave__driver.html#structspi__slave__user__config__t">spi_slave_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>slaveConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function un-gates the clock to the SPI module, initializes the SPI for slave mode. After it is initialized, the SPI module is configured in slave mode and the user can start transmitting and receiving data by calling send, receive, and transfer functions. This function indicates SPI slave uses an interrupt mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
    <tr><td class="paramname">spiState</td><td>The pointer to the SPI slave driver state structure. </td></tr>
    <tr><td class="paramname">slaveConfig</td><td>The configuration structure <a class="el" href="group__spi__slave__driver.html#structspi__slave__user__config__t" title="User configuration structure for the SPI slave driver. ">spi_slave_user_config_t</a> which configures the data bus format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kStatus_SPI_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf62ec2a9e9c2dec1110a2b9da0c5f6df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_SlaveDeinit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the SPI module, gates its clock, and changes the SPI slave driver state to NonInit for the SPI slave module which is initialized with interrupt mechanism. After de-initialization, the user can re-initialize the SPI slave module with other mechanisms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kStatus_SPI_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="gab6ecb26a766c21d1a953f45377677e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_SlaveTransferBlocking </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>sendBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>receiveBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>transferByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function checks the driver status and mechanism, and transmits/receives data through the SPI bus. If the sendBuffer is NULL, the transmit process is ignored. If the receiveBuffer is NULL, the receive process is ignored. If both the receiveBuffer and the sendBuffer are available, the transmit and the receive progress is processed. If only the receiveBuffer is available, the receive is processed. Otherwise, the transmit is processed. This function only returns when the processes are completed. This function uses an interrupt mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of SPI peripheral </td></tr>
    <tr><td class="paramname">sendBuffer</td><td>The pointer to data that user wants to transmit. </td></tr>
    <tr><td class="paramname">receiveBuffer</td><td>The pointer to data that user wants to store received data. </td></tr>
    <tr><td class="paramname">transferByteCount</td><td>The number of bytes to send and receive. </td></tr>
    <tr><td class="paramname">timeout</td><td>The maximum number of milliseconds that function waits before timed out reached.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_SPI_Success if driver starts to send/receive data successfully. kStatus_SPI_Error if driver is error and needs to clean error. kStatus_SPI_Busy if driver is receiving/transmitting data and not available. kStatus_SPI_Timeout if time out reached while transferring is in progress. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b403edde9f60af0b9bd16639aae32bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_SlaveTransfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>sendBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>receiveBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>transferByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function checks the driver status and sets buffer pointers to receive and transmit SPI data. If the sendBuffer is NULL, the transmit process is ignored. If the receiveBuffer is NULL, the receive process is ignored. If both the receiveBuffer and the sendBuffer are available, the transfer is done when the kDspiTxDone and kDspiRxDone are set. If only the receiveBuffer is available, the transfer is done when the kDspiRxDone flag is set. Otherwise, the transfer is done when the kDspiTxDone was set. This function uses an interrupt mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of SPI peripheral </td></tr>
    <tr><td class="paramname">sendBuffer</td><td>The pointer to data that user wants to transmit. </td></tr>
    <tr><td class="paramname">receiveBuffer</td><td>The pointer to data that user wants to store received data. </td></tr>
    <tr><td class="paramname">transferByteCount</td><td>The number of bytes to send and receive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_SPI_Success if driver starts to send/receive data successfully. kStatus_SPI_Error if driver is error and needs to clean error. kStatus_SPI_Busy if driver is receiving/transmitting data and not available. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b194593011b75cb62ed78f6aaeb8774"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_SlaveAbortTransfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function stops the transfer which was started by the calling the <a class="el" href="group__spi__slave__driver.html#ga6b403edde9f60af0b9bd16639aae32bc" title="Starts the transfer data on SPI bus using an interrupt and a non-blocking call. ">SPI_DRV_SlaveTransfer()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of SPI peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_SPI_Success if everything is OK. kStatus_SPI_InvalidMechanism if the current transaction does not use interrupt mechanism. </dd></dl>

</div>
</div>
<a class="anchor" id="ga942a195e13c80f7e4738a5f3ab7d246c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__spi__hal.html#ga856ecadf3d7fe18c4fc3ae56500f8982">spi_status_t</a> SPI_DRV_SlaveGetTransferStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>framesTransferred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When performing an a-sync transfer, the user can call this function to ascertain the state of the current transfer: in progress (or busy) or complete (success). In addition, if the transfer is still in progress, the user can get the number of words that have been transferred up to now.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the SPI peripheral. </td></tr>
    <tr><td class="paramname">framesTransferred</td><td>Pointer to value that is filled in with the number of frames that have been sent in the active transfer. A frame is defined as the number of bits per frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_SPI_Success The transfer has completed successfully, or kStatus_SPI_Busy The transfer is still in progress. framesTransferred is filled with the number of words that have been transferred so far. </dd></dl>

</div>
</div>
<a class="anchor" id="ga484943d1ff5370777788dee055f6fa49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPI_DRV_SlaveIRQHandler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance number of the SPI module. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga0456d58013e06bb298faa3a13a921d17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_Type* const g_spiBase[SPI_INSTANCE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf1f7b62f63fbb61de81f98fd1042980f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IRQn_Type g_spiIrqId[SPI_INSTANCE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0456d58013e06bb298faa3a13a921d17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_Type* const g_spiBase[SPI_INSTANCE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf1f7b62f63fbb61de81f98fd1042980f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IRQn_Type g_spiIrqId[SPI_INSTANCE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer">Thu Sep 24 2015 &copy; 2015 Freescale Semiconductor, Inc. All rights reserved.
    </li>
  </ul>
</div>
</body>
</html>
