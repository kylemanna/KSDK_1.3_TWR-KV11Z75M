<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Kinetis SDK v.1.3 API Reference Manual: DSPI Master Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fs_logo.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Kinetis SDK v.1.3 API Reference Manual
   &#160;<span id="projectnumber">Rev. 0</span>
   </div>
   <div id="projectbrief">Freescale Semiconductor, Inc.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__dspi__master__driver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">DSPI Master Driver<div class="ingroups"><a class="el" href="group__dspi.html">Serial Peripheral Interface (DSPI)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p>This section describes the programming interface of the DSPI master mode peripheral driver. The DSPI master mode peripheral driver transfers data to and from external devices on the DSPI bus in master mode. It supports transferring data buffers with a single function call.</p>
<h1><a class="anchor" id="DSPIIntr"></a>
DSPI Introduction</h1>
<p>The driver is separated into two implementations: interrupt-driven and DMA-driven. The interrupt-driven driver uses interrupts to alert the CPU that the DSPI module needs to service the SPI data transmit and receive operations. The enhanced DMA (eDMA)-driven driver uses the eDMA module to transfer data between the buffers located in memory and the DSPI module transmit/receive buffers/FIFOs. In the subsequent sections the enhanced DMA-driven driver is referred to as the DMA-driven driver. The interrupt-driven and DMA-driven driver APIs are distinguished with the keyword "edma" in the source file name and by the keyword "Edma" in the API name. Each set of drivers have the same API functionality and are described in the following sections. Note that the DMA driven driver also uses interrupts to alert the CPU that the DMA has completed its transfer or that one final piece of data still needs to be received which is handled by the IRQ handler in the DMA driven driver. In both the interrupt and DMA drivers, the SPI module interrupts are enabled in the NVIC. In addition, the DMA driven-driver requests channels from the eDMA module. Also, these sections refer to either set of drivers as the "DSPI master driver" when discussing items that pertain to either driver. Note, when using the DMA driven DSPI driver, initialize the eDMA module. An example is shown in the Initialization section.</p>
<p>This is a step-by-step process to initialize and transfer the SPI data. For API specific examples, see the examples below. The example uses the interrupt-driven APIs and a blocking transfer to illustrate a high-level step-by-step usage. The usage of eDMA driver is similar to the interrupt-driven driver. Keep in mind that using interrupt and eDMA drivers in the same runtime application is not recommended because the SPI interrupt handler needs to be changed. The interrupt driver calls the <a class="el" href="group__dspi__shared__irq.html#ga006679b7b9dd4584a63c2528075a7d46" title="The function DSPI_DRV_IRQHandler passes IRQ control to either the master or slave driver...">DSPI_DRV_IRQHandler()</a> function and the eDMA driver calls the <a class="el" href="group__dspi__shared__irq.html#gac949f5e2aee9e3bc394e8ba627c2f865" title="The function DSPI_DRV_EdmaIRQHandler passes IRQ control to either the master or slave driver...">DSPI_DRV_EdmaIRQHandler()</a> function. See files fsl_dspi_irq.c and fsl_dspi_edma_irq.c for an example of these function calls.</p>
<div class="fragment"><div class="line"><span class="comment">// Initializes the DSPI</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga37d57c2ed98daaa6340d50054d617967">DSPI_DRV_MasterInit</a>(masterInstance, &amp;dspiMasterState, &amp;userConfig);</div>
<div class="line"><span class="comment">// Configure the SPI bus</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga484ec4f6557a5f8aa3dffa4dfc7b3ba0">DSPI_DRV_MasterConfigureBus</a>(masterInstance, &amp;spiDevice, &amp;calculatedBaudRate);</div>
<div class="line"><span class="comment">// Optional; Normally the user does not need to adjust delays, but depends on the slave device:</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga705cfda5272cff31714e7167eed5ca7c">DSPI_DRV_MasterSetDelay</a>(masterInstance, <a class="code" href="group__dspi__hal.html#gga1ca2fbee37b3cb046c075a7e765d64eda1b1297e9388df6c83b58ca3bbb3cb267">kDspiPcsToSck</a>, delayInNanoSec, &amp;calculatedDelay);</div>
<div class="line"><span class="comment">// Perform the transfer</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#gad4a5101fdb19f5b242f1ad06d9c93b4e">DSPI_DRV_MasterTransferBlocking</a>(masterInstance, NULL, s_dspiSourceBuffer,</div>
<div class="line">                                s_dspiSinkBuffer, 32, 1000);</div>
<div class="line"><span class="comment">// Do other transfers. When done with the DSPI, de-initialize to shut it down.</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#gaf173a42da34da0bfa391f629b8bbfd44">DSPI_DRV_MasterDeinit</a>(masterInstance);</div>
</div><!-- fragment --><p>Note that it is not recommended to mix interrupt and DMA driven drivers in the same application. However, should the user decide to do so, separately set up and initialize another instance for DMA operations. The user can also de-initialize the current interrupt-driven DSPI instance and re-initialize it for DMA operations. Note, that, because the DMA driven driver also uses interrupts, the user must direct the IRQ handler from the vector table to the desired driver's IRQ handler. See files fsl_dspi_irq.c and fsl_dspi_edma_irq.c for examples on how to re-direct the IRQ handlers from the vector table to the interrupt-driven and DMA-driven driver IRQ handlers. Such files need to be included in the application project to direct the DSPI interrupt vectors to the proper IRQ handlers. The fsl_dspi_shared_function.c and fsl_dspi_edma_shared_function.c files direct the interrupts from the vector table to the appropriate master or slave driver interrupt handler by checking the DSPI mode via the HAL function DSPI_HAL_IsMaster(baseAddr). Note that the interrupt driver calls the <a class="el" href="group__dspi__shared__irq.html#ga006679b7b9dd4584a63c2528075a7d46" title="The function DSPI_DRV_IRQHandler passes IRQ control to either the master or slave driver...">DSPI_DRV_IRQHandler()</a> function and the eDMA driver calls the <a class="el" href="group__dspi__shared__irq.html#gac949f5e2aee9e3bc394e8ba627c2f865" title="The function DSPI_DRV_EdmaIRQHandler passes IRQ control to either the master or slave driver...">DSPI_DRV_EdmaIRQHandler()</a> function. See files fsl_dspi_irq.c and fsl_dspi_edma_irq.c for an example of these function calls.</p>
<p>When using the DSPI driver with the eDMA some DSPI instances do not support separate DMA requests for transmit and receive channels. In those cases with a single shared DMA request for transmit and receive DMA channels, the driver links one channel to the other to still take advantage of DMA transfers. However, the drawback to using an instance with shared DMA requests limits the maximum amount of data the driver can transfer. This limit depends on the bits/frame setting.</p>
<p>For DSPI instances with separate transmit and receive DMA requests, the maximum number of bytes that can be transferred is: 8-bit setting: 32767 bytes 16-bit setting: 65534 bytes</p>
<p>For DSPI instances with a shared transmit and receive DMA request, the maximum number of bytes that can be transferred is: 8-bit setting: 511 bytes 16-bit setting: 1022 bytes</p>
<p>See the microcontroller-specific documentation to see which DSPI instance have separate or shared transmit and receive DMA requests. Additionally, see the microcontroller-specific feature header file to see which DSPI instance have separate or shared transmit and receive DMA requests.</p>
<h1><a class="anchor" id="DSPIRTss"></a>
DSPI Run-time state structures</h1>
<p>The DSPI master driver uses a run-time state structure to track the ongoing data transfers. The state structure for the interrupt-driven driver is called the <a class="el" href="group__dspi__master__driver.html#structdspi__master__state__t" title="Runtime state structure for the DSPI master driver. ">dspi_master_state_t</a>. The structure for the DMA driven driver is called the <a class="el" href="group__dspi__master__driver.html#structdspi__edma__master__state__t" title="Runtime state structure for the DSPI master driver with EDMA. ">dspi_edma_master_state_t</a>. This structure holds data that the DSPI master peripheral driver uses to communicate between the transfer function and the interrupt handler and other driver functions. The interrupt handler in the interrupt driven also uses this information to keep track of its progress. The user is only required to pass the memory for the run-time state structure. The DSPI master driver populates the members.</p>
<h1><a class="anchor" id="DSPIUcs"></a>
DSPI User configuration structures</h1>
<p>The DSPI master driver uses instances of the user configuration structure for the DSPI master driver. The user configuration structure for the interrupt-driven driver is called the <a class="el" href="group__dspi__master__driver.html#structdspi__master__user__config__t" title="The user configuration structure for the DSPI master driver. ">dspi_master_user_config_t</a>. The user configuration structure for the DMA driven driver is called the <a class="el" href="group__dspi__master__driver.html#structdspi__edma__master__user__config__t" title="The user configuration structure for the DSPI master driver with EDMA. ">dspi_edma_master_user_config_t</a>. This structure allows the user to configure the most common settings of the DSPI peripheral with a single function call. The user configuration structure is passed into the master driver initialization function (DSPI_DRV_MasterInit or DSPI_DRV_EdmaMasterInit). The user configuration structure consists of whichCtar (generally set this to kDspiCtar0), option for continuous clock and peripheral chip select, the desired peripheral chip select to use, and the polarity of the peripheral chip select settings. An example of this is provided in the Initialization section.</p>
<h1><a class="anchor" id="DSPIDs"></a>
DSPI Device structures</h1>
<p>The DSPI master driver uses instances of the <a class="el" href="group__dspi__master__driver.html#structdspi__device__t" title="Data structure containing information about a device on the SPI bus. ">dspi_device_t</a> or <a class="el" href="group__dspi__master__driver.html#structdspi__edma__device__t" title="Data structure containing information about a device on the SPI bus with EDMA. ">dspi_edma_device_t</a> structure to represent the SPI bus configuration required to communicate to an external device that is connected to the bus.</p>
<p>The device structure can be passed into the DSPI_DRV_MasterConfigureBus or DSPI_DRV_EdmaMasterConfigureBus functions to manually configure the bus for a particular device. For example, if there is only one device connected to the bus, the user might configure it only once. Alternatively, the device structure can be passed to the data transfer functions where the bus is reconfigured before the transfer is started. The device structure consists of bitsPerSec (baud rate in Hz) and the dataBusConfig structure which consists of bits per frame, clock polarity and phase, and data shift direction (MSB or LSB).</p>
<h1><a class="anchor" id="DSPIInit"></a>
DSPI Initialization</h1>
<p>To initialize the DSPI master driver, call the <a class="el" href="group__dspi__master__driver.html#ga37d57c2ed98daaa6340d50054d617967" title="Initializes a DSPI instance for master mode operation. ">DSPI_DRV_MasterInit()</a> or the DSPI_DRV_EdmaMasterInit functions and pass the instance number of the DSPI peripheral, the memory allocation for the run-time state structure used by the master driver to keep track of data transfers, and the user configuration (<a class="el" href="group__dspi__master__driver.html#structdspi__master__user__config__t" title="The user configuration structure for the DSPI master driver. ">dspi_master_user_config_t</a> or <a class="el" href="group__dspi__master__driver.html#structdspi__edma__master__user__config__t" title="The user configuration structure for the DSPI master driver with EDMA. ">dspi_edma_master_user_config_t</a>). For the DMA driven driver, the memory allocation for the stcdSrc2CmdDataLast structure needs to be passed. Note that the pointer to this structure needs to be aligned to a 32-byte boundary.</p>
<p>First call the DSPI master initialization to initialize the DSPI module. Then, call the DSPI master configuration bus to configure the module for the specific device on the SPI bus. For the interrupt-driven case, while the <a class="el" href="group__dspi__master__driver.html#ga37d57c2ed98daaa6340d50054d617967" title="Initializes a DSPI instance for master mode operation. ">DSPI_DRV_MasterInit()</a> function initializes the DSPI peripheral, the <a class="el" href="group__dspi__master__driver.html#ga484ec4f6557a5f8aa3dffa4dfc7b3ba0" title="Configures the DSPI port physical parameters to access a device on the bus. ">DSPI_DRV_MasterConfigureBus()</a> function configures the SPI bus parameters such as bits/frame, clock characteristics, data shift direction, baud rate, and desired chip select. The DMA-driven case follows the same logic, except that it uses the EDMA API names. Both examples are provided below. The interrupt driven example is provided first followed by the DMA example.</p>
<p>This is an example code to initialize and configure the DSPI master interrupt-driven driver including setting up the user configuration and device structures: </p>
<div class="fragment"><div class="line"><span class="comment">// Set up and initialize the master  //</span></div>
<div class="line">uint32_t masterInstance = 1;  <span class="comment">// example using DSPI instance 1</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#structdspi__master__state__t">dspi_master_state_t</a> dspiMasterState; <span class="comment">// simply allocate memory for this</span></div>
<div class="line">uint32_t calculatedBaudRate;</div>
<div class="line"></div>
<div class="line"><span class="comment">// configure the members of the user configuration //</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#structdspi__master__user__config__t">dspi_master_user_config_t</a> userConfig;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#ada9c810904ee8e24abefb25b9045c125">isChipSelectContinuous</a> = <span class="keyword">false</span>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#a6c46d04d4031ebb56a12c665a0d17aaa">isSckContinuous</a> = <span class="keyword">false</span>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#aa8b1f2458668337b90a340a4ecaf4aa4">pcsPolarity</a> = <a class="code" href="group__dspi__hal.html#ggab466e73cb54b2c023459d43918c4197daf89a174f7da2c2d1dd94eaee5f451ac7">kDspiPcs_ActiveLow</a>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#a8514df82b4b4c68f4de58a3ed160faf1">whichCtar</a> = <a class="code" href="group__dspi__hal.html#gga992d5562af4cf4c45371feb8c5c1a1bfa21d94da5d7c4e6134907fad358147b35">kDspiCtar0</a>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#a6433c1800d2a85da45ae347022c3cd9b">whichPcs</a> = <a class="code" href="group__dspi__hal.html#gga3d9d9a8fe16a51e6c697a547ab65bef1aae6b37fc82d8d2b7425b85dd63172acf">kDspiPcs1</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Initialize the DSPI module //</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga37d57c2ed98daaa6340d50054d617967">DSPI_DRV_MasterInit</a>(masterInstance, &amp;dspiMasterState, &amp;userConfig);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Define the bus configuration</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#structdspi__device__t">dspi_device_t</a> spiDevice;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#a99d8d0dec68d5d2c1de35f8bb8b66a75">bitsPerFrame</a> = 16;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#ad751cbe15bfe01f02088e2a36059774a">clkPhase</a> = <a class="code" href="group__dspi__hal.html#gga4269ec144334dd60666a92e6fd2c1476ada723d5970a0b0a28d96a0e707cabd9c">kDspiClockPhase_FirstEdge</a>;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#a8926c27980536d08b063f984cc5dc751">clkPolarity</a> = <a class="code" href="group__dspi__hal.html#gga1e0a9074742794ef89f597d220296651afffdb6de18c3b46c509c406ac7230586">kDspiClockPolarity_ActiveHigh</a>;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#a7b5fc2246586c461ebd0325bba2e3113">direction</a> = <a class="code" href="group__dspi__hal.html#gga06fad8ae17b680f6dddfd798c9d3b30daed75ebb641f649ff0c4eb77d2624bcf2">kDspiMsbFirst</a>;</div>
<div class="line">spiDevice.<a class="code" href="group__dspi__master__driver.html#ac497d381e4bb407f8968ad34c47e7abd">bitsPerSec</a> = 500000;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Configure the SPI bus //</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga484ec4f6557a5f8aa3dffa4dfc7b3ba0">DSPI_DRV_MasterConfigureBus</a>(masterInstance, &amp;spiDevice, &amp;calculatedBaudRate);</div>
</div><!-- fragment --><p>This is an example code to initialize and configure the DSPI master DMA-driven driver including setting up the user configuration and device structures: </p>
<div class="fragment"><div class="line"><span class="comment">// Declare 32-byte aligned software transfer control descriptor (eDMA requirement)</span></div>
<div class="line"><span class="comment">// This example uses IAR preprocessor pragma syntax.  Other methods also include declaring</span></div>
<div class="line"><span class="comment">// a 64-byte region and then aligning the pointer within that region to a 32-byte boundary,</span></div>
<div class="line"><span class="comment">// but this would waste 32-bytes of memory</span></div>
<div class="line"><span class="preprocessor">#pragma data_alignment=32</span></div>
<div class="line"><span class="preprocessor"></span>    <a class="code" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> stcdTransferCntTest;</div>
<div class="line"></div>
<div class="line"><span class="comment">// First,  initialize the eDMA peripheral driver.</span></div>
<div class="line"><span class="comment">// NOTE: THIS IS NOT PART OF THE DSPI DRIVER. THIS PART INITIALIZES THE EDMA DRIVER SO</span></div>
<div class="line"><span class="comment">// THAT THE DSPI EDMA DRIVER CAN WORK.</span></div>
<div class="line"><a class="code" href="group__edma__driver.html#structedma__state__t">edma_state_t</a> state;  <span class="comment">//  &lt;- The user allocates memory for this structure.</span></div>
<div class="line"><a class="code" href="group__edma__driver.html#structedma__user__config__t">edma_user_config_t</a> edmaUserConfig;  <span class="comment">// &lt;- The user fills out members for this structure.</span></div>
<div class="line"></div>
<div class="line">edmaUserConfig.<a class="code" href="group__edma__driver.html#af6a9367e435cdcc1a239a7ccbd38aa13">chnArbitration</a> = <a class="code" href="group__edma__hal.html#gga1ae691e6c3e3af80d079f01dc4e0d9d9acb97728581b710ac5b456c4f52e4b9ad">kEDMAChnArbitrationRoundrobin</a>;</div>
<div class="line">edmaUserConfig.<a class="code" href="group__edma__driver.html#a3d0df54ed2a5b6840db6a279d6ba9066">notHaltOnError</a> = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Actual EDMA initialization</span></div>
<div class="line"><a class="code" href="group__edma__driver.html#ga7deb54a7e997d79de1ed7c4e85290688">EDMA_DRV_Init</a>(&amp;state, &amp;edmaUserConfig);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Set up and initialize the master  //</span></div>
<div class="line">uint32_t masterInstance = 0;  <span class="comment">// example using DSPI instance 0</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#structdspi__edma__master__state__t">dspi_edma_master_state_t</a> dspiMasterState; <span class="comment">// simply allocate memory for this</span></div>
<div class="line">uint32_t calculatedBaudRate;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Configure the members of the user configuration //</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#structdspi__edma__master__user__config__t">dspi_edma_master_user_config_t</a> userConfig;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#a48fd49026678919882db3f457aef07da">isChipSelectContinuous</a> = <span class="keyword">false</span>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#af07a5d781ecdd79c5615264c24654726">isSckContinuous</a> = <span class="keyword">false</span>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#ad0e98667e6269f6138154852b1bc9a99">pcsPolarity</a> = <a class="code" href="group__dspi__hal.html#ggab466e73cb54b2c023459d43918c4197daf89a174f7da2c2d1dd94eaee5f451ac7">kDspiPcs_ActiveLow</a>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#a9a44b97547b785015cf8383d4c5a43c9">whichCtar</a> = <a class="code" href="group__dspi__hal.html#gga992d5562af4cf4c45371feb8c5c1a1bfa21d94da5d7c4e6134907fad358147b35">kDspiCtar0</a>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#abfd1f1c44dd7177a070d08e2884ef1d1">whichPcs</a> = <a class="code" href="group__dspi__hal.html#gga3d9d9a8fe16a51e6c697a547ab65bef1aae6b37fc82d8d2b7425b85dd63172acf">kDspiPcs1</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Initialize the DSPI module //</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga056aee779cd846ee43d4dc778f5ee6bc">DSPI_DRV_EdmaMasterInit</a>(masterInstance, &amp;dspiMasterState, &amp;userConfig, &amp;stcdTransferCntTest);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Define the bus configuration</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#structdspi__edma__device__t">dspi_edma_device_t</a> spiDevice;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#a99d8d0dec68d5d2c1de35f8bb8b66a75">bitsPerFrame</a> = 16;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#ad751cbe15bfe01f02088e2a36059774a">clkPhase</a> = <a class="code" href="group__dspi__hal.html#gga4269ec144334dd60666a92e6fd2c1476ada723d5970a0b0a28d96a0e707cabd9c">kDspiClockPhase_FirstEdge</a>;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#a8926c27980536d08b063f984cc5dc751">clkPolarity</a> = <a class="code" href="group__dspi__hal.html#gga1e0a9074742794ef89f597d220296651afffdb6de18c3b46c509c406ac7230586">kDspiClockPolarity_ActiveHigh</a>;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#a7b5fc2246586c461ebd0325bba2e3113">direction</a> = <a class="code" href="group__dspi__hal.html#gga06fad8ae17b680f6dddfd798c9d3b30daed75ebb641f649ff0c4eb77d2624bcf2">kDspiMsbFirst</a>;</div>
<div class="line">spiDevice.<a class="code" href="group__dspi__master__driver.html#a11c692151d0c51699d2818c4dc9ff29a">bitsPerSec</a> = 500000;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Configure the SPI bus //</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga87b4ad456a0f360cb1bb22d9c0fd3dcb">DSPI_DRV_EdmaMasterConfigureBus</a>(masterInstance, &amp;spiDevice, &amp;calculatedBaudRate);</div>
</div><!-- fragment --><p>The DSPI also offers an optional API to configure various bus timing delays. This function involves the DSPI module delay options to "fine tune" some of the signal timings and match the timing needs of a slower peripheral device. This is an optional function that can be called after the DSPI module is initialized for master mode. The bus timing delays that can be adjusted are listed here:</p>
<p>PCS to SCK Delay: Adjustable delay option between the assertion of the PCS signal to the first SCK edge.</p>
<p>After SCK Delay: Adjustable delay option between the last edge of SCK to the de-assertion of the PCS signal.</p>
<p>Delay after Transfer: Adjustable delay option between the de-assertion of the PCS signal for a frame to the assertion of the PCS signal for the next frame. Note that this is not adjustable for continuous clock mode because this delay is fixed at one SCK period.</p>
<p>This function takes in as a parameter the desired delay type and the delay value (in nanoseconds) and calculates the values needed for the prescaler and scaler. Returning the actual calculated delay as an exact delay match may not be possible. In this situation, the closest match is calculated without going below the desired delay value input. It is possible to input a very large delay value that exceeds the capability of the part, in which case the maximum supported delay is returned. In addition, the function returns an out-of-range status.</p>
<p>This is an example that shows how to use the set the bus timings delay function: </p>
<div class="fragment"><div class="line">    uint32_t delayInNanoSec = 200;  <span class="comment">// example, 200ns</span></div>
<div class="line">    uint32_t calculatedDelay;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Interrupt example</span></div>
<div class="line"><span class="comment">// kDspiPcsToSck: PCS to SCK Delay option, delayInNanoSec is the user&#39;s passed in delay in ns</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga705cfda5272cff31714e7167eed5ca7c">DSPI_DRV_MasterSetDelay</a>(masterInstance, <a class="code" href="group__dspi__hal.html#gga1ca2fbee37b3cb046c075a7e765d64eda1b1297e9388df6c83b58ca3bbb3cb267">kDspiPcsToSck</a>, delayInNanoSec, &amp;calculatedDelay);</div>
<div class="line"></div>
<div class="line"><span class="comment">// eDMA example</span></div>
<div class="line"><span class="comment">// kDspiPcsToSck: PCS to SCK Delay option, delayInNanoSec is the user&#39;s passed in delay in ns</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga952853adf4ad08153e70b0f78cf2d926">DSPI_DRV_EdmaMasterSetDelay</a>(masterInstance, <a class="code" href="group__dspi__hal.html#gga1ca2fbee37b3cb046c075a7e765d64eda1b1297e9388df6c83b58ca3bbb3cb267">kDspiPcsToSck</a>, delayInNanoSec, &amp;calculatedDelay);</div>
</div><!-- fragment --><h1><a class="anchor" id="DSPItrnsf"></a>
DSPI Transfers</h1>
<p>The driver supports two different modes for transferring data: blocking and non-blocking (async). The blocking transfer function waits until the transfer is complete before returning. A timeout parameter is passed into the blocking function. A non-blocking (async) function returns immediately after starting the transfer. The user is required to get the transfer status during the transfer to ascertain when the transfer is complete. Additional functions provided to aid in non-blocking transfers are get transfer status and abort transfer. If there is a cache for memory, when using DMA to transfer data, ensure that the data is consistent. In other words, when reading the data from memory, application should ensure that the data to/from the memory device is current and is not not cached.</p>
<p>Blocking transfer function APIs (interrupt and DMA driven): </p>
<div class="fragment"><div class="line"><a class="code" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> <a class="code" href="group__dspi__master__driver.html#gad4a5101fdb19f5b242f1ad06d9c93b4e">DSPI_DRV_MasterTransferBlocking</a>(uint32_t instance,</div>
<div class="line">                                              <span class="keyword">const</span> <a class="code" href="group__dspi__master__driver.html#structdspi__device__t">dspi_device_t</a> * restrict device,</div>
<div class="line">                                              <span class="keyword">const</span> uint8_t * sendBuffer,</div>
<div class="line">                                              uint8_t * receiveBuffer,</div>
<div class="line">                                              <span class="keywordtype">size_t</span> transferByteCount,</div>
<div class="line">                                              uint32_t timeout);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> <a class="code" href="group__dspi__master__driver.html#ga494b8d6379bd3879cfc7f59f7129bbf0">DSPI_DRV_EdmaMasterTransferBlocking</a>(uint32_t instance,</div>
<div class="line">                                                  <span class="keyword">const</span> <a class="code" href="group__dspi__master__driver.html#structdspi__edma__device__t">dspi_edma_device_t</a> * restrict device,</div>
<div class="line">                                                  <span class="keyword">const</span> uint8_t * sendBuffer,</div>
<div class="line">                                                  uint8_t * receiveBuffer,</div>
<div class="line">                                                  <span class="keywordtype">size_t</span> transferByteCount,</div>
<div class="line">                                                  uint32_t timeout);</div>
</div><!-- fragment --><p>Non-blocking function APIs and associated functions (interrupt and DMA-driven): </p>
<div class="fragment"><div class="line"><span class="comment">// Interrupt-driven transfer function</span></div>
<div class="line"><a class="code" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> <a class="code" href="group__dspi__master__driver.html#ga2d475636c45ae6f0f2bced51deb37487">DSPI_DRV_MasterTransfer</a>(uint32_t instance,</div>
<div class="line">                                      <span class="keyword">const</span> <a class="code" href="group__dspi__master__driver.html#structdspi__device__t">dspi_device_t</a> * restrict device,</div>
<div class="line">                                      <span class="keyword">const</span> uint8_t * sendBuffer,</div>
<div class="line">                                      uint8_t * receiveBuffer,</div>
<div class="line">                                      <span class="keywordtype">size_t</span> transferByteCount);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Returns whether the previous transfer is completed (interrupt-driven )</span></div>
<div class="line"><a class="code" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> <a class="code" href="group__dspi__master__driver.html#ga4c962f4f1d462d30d275c52f118d04c5">DSPI_DRV_MasterGetTransferStatus</a>(uint32_t instance, uint32_t * framesTransferred);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Terminates an asynchronous transfer early (interrupt-driven )</span></div>
<div class="line"><a class="code" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> <a class="code" href="group__dspi__master__driver.html#ga08ca2ffc48f8a7fe72694571e067b5a1">DSPI_DRV_MasterAbortTransfer</a>(uint32_t instance);</div>
<div class="line"></div>
<div class="line"><span class="comment">// DMA-driven transfer function</span></div>
<div class="line"><a class="code" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> <a class="code" href="group__dspi__master__driver.html#ga72a411c2ed35d3ae70267601c4a8115e">DSPI_DRV_EdmaMasterTransfer</a>(uint32_t instance,</div>
<div class="line">                                          <span class="keyword">const</span> <a class="code" href="group__dspi__master__driver.html#structdspi__edma__device__t">dspi_edma_device_t</a> * restrict device,</div>
<div class="line">                                          <span class="keyword">const</span> uint8_t * sendBuffer,</div>
<div class="line">                                          uint8_t * receiveBuffer,</div>
<div class="line">                                          <span class="keywordtype">size_t</span> transferByteCount);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Returns whether the previous transfer is completed (DMA-driven)</span></div>
<div class="line"><a class="code" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> <a class="code" href="group__dspi__master__driver.html#ga45330690d03a2c0c249d94322141d297">DSPI_DRV_EdmaMasterGetTransferStatus</a>(uint32_t instance, uint32_t * framesTransferred);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Terminates an asynchronous transfer early (DMA-driven)</span></div>
<div class="line"><a class="code" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> <a class="code" href="group__dspi__master__driver.html#gae8710c8a2abd897a2ccd4a3461fa3dd3">DSPI_DRV_EdmaMasterAbortTransfer</a>(uint32_t instance);</div>
</div><!-- fragment --><p>Example of a blocking transfer (interrupt and DMA-driven). Note that the peripheral driver must be initialized first. See the Initialization Section for initialization information. </p>
<div class="fragment"><div class="line"><span class="comment">// Example blocking transfer function call (interrupt)</span></div>
<div class="line"><span class="comment">// Note: providing another device structure is optional and for this example, the assumption is that</span></div>
<div class="line"><span class="comment">// the DSPI_DRV_MasterConfigureBus was sufficient and NULL is passed for the device</span></div>
<div class="line"><span class="comment">// structure.  Also, this example shows that 32 bytes are transferred with a timeout of 1000 µs.</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#gad4a5101fdb19f5b242f1ad06d9c93b4e">DSPI_DRV_MasterTransferBlocking</a>(masterInstance, NULL, s_dspiSourceBuffer,</div>
<div class="line">                                    s_dspiSinkBuffer, 32, 1000);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Example blocking transfer function call (DMA)</span></div>
<div class="line"><span class="comment">// Note: providing another device structure is optional and for this example, the assumption is that</span></div>
<div class="line"><span class="comment">// the DSPI_DRV_MasterConfigureBus was sufficient and NULL is passed for the device</span></div>
<div class="line"><span class="comment">// structure. Also, this example shows that 32 bytes are transferred with a timeout of 1000 µs.</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga494b8d6379bd3879cfc7f59f7129bbf0">DSPI_DRV_EdmaMasterTransferBlocking</a>(masterInstance, NULL, s_dspiSourceBuffer,</div>
<div class="line">                                        s_dspiSinkBuffer, 32, 1000);</div>
</div><!-- fragment --><p>Example of a non-blocking transfer (interrupt and DMA-driven). Note that the peripheral driver must be initialized first. See the Initialization Section for initialization information. </p>
<div class="fragment"><div class="line"><span class="comment">// Interrupt Example</span></div>
<div class="line"><span class="comment"></span>uint32_t framesXfer;</div>
<div class="line"><span class="comment">// Example non-blocking transfer function call</span></div>
<div class="line"><span class="comment">// Note: providing another device structure is optional and for this example, the assumption is that</span></div>
<div class="line"><span class="comment">// the DSPI_DRV_MasterConfigureBus was sufficient and NULL is passed for the device</span></div>
<div class="line"><span class="comment">// structure. Also, this example shows that 32 bytes is transferred.</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga2d475636c45ae6f0f2bced51deb37487">DSPI_DRV_MasterTransfer</a>(masterInstance, NULL, s_dspiSourceBuffer, s_dspiSinkBuffer, 32);</div>
<div class="line"></div>
<div class="line"><span class="comment">// For non-blocking/async transfers, check back to get transfer status. For example,</span></div>
<div class="line"><span class="comment">// where framesXfer returns the number of frames transferred //</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga4c962f4f1d462d30d275c52f118d04c5">DSPI_DRV_MasterGetTransferStatus</a>(masterInstance, &amp;framesXfer);</div>
<div class="line"></div>
<div class="line"><span class="comment">// This is an example to terminate the on-going transfer:</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga08ca2ffc48f8a7fe72694571e067b5a1">DSPI_DRV_MasterAbortTransfer</a>(masterInstance);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// DMA Example</span></div>
<div class="line"><span class="comment"></span><span class="comment">// Example non-blocking transfer function call</span></div>
<div class="line"><span class="comment">// Note: providing another device structure is optional and for this example, the assumption is that</span></div>
<div class="line"><span class="comment">// the DSPI_DRV_MasterConfigureBus was sufficient and NULL is passed for the device</span></div>
<div class="line"><span class="comment">// structure. Also, this example shows that 32 bytes is transferred.</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga72a411c2ed35d3ae70267601c4a8115e">DSPI_DRV_EdmaMasterTransfer</a>(masterInstance, NULL, s_dspiSourceBuffer, s_dspiSinkBuffer, 32);</div>
<div class="line"></div>
<div class="line"><span class="comment">// For non-blocking/async transfers, check back to get transfer status. For example,</span></div>
<div class="line"><span class="comment">// where framesXfer returns the number of frames transferred //</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga45330690d03a2c0c249d94322141d297">DSPI_DRV_EdmaMasterGetTransferStatus</a>(masterInstance, &amp;framesXfer);</div>
<div class="line"></div>
<div class="line"><span class="comment">// This is an example to terminate the on-going transfer:</span></div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#gae8710c8a2abd897a2ccd4a3461fa3dd3">DSPI_DRV_EdmaMasterAbortTransfer</a>(masterInstance);</div>
</div><!-- fragment --><h1><a class="anchor" id="DSPIDeinit"></a>
DSPI De-initialization</h1>
<p>To deinitialize and shut down the DSPI module, call this function: </p>
<div class="fragment"><div class="line"><span class="comment">// interrupt-driven</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="group__dspi__master__driver.html#gaf173a42da34da0bfa391f629b8bbfd44">DSPI_DRV_MasterDeinit</a>(masterInstance);</div>
<div class="line"></div>
<div class="line"><span class="comment">// DMA-driven</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="group__dspi__master__driver.html#ga3ec2de01872d7f75a27bb68c34edc710">DSPI_DRV_EdmaMasterDeinit</a>(masterInstance);</div>
</div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structdspi__dma__device__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#structdspi__dma__device__t">dspi_dma_device_t</a></td></tr>
<tr class="memdesc:structdspi__dma__device__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure containing information about a device on the SPI bus with DMA.  <a href="group__dspi__master__driver.html#structdspi__dma__device__t">More...</a><br/></td></tr>
<tr class="separator:structdspi__dma__device__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structdspi__dma__master__state__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#structdspi__dma__master__state__t">dspi_dma_master_state_t</a></td></tr>
<tr class="memdesc:structdspi__dma__master__state__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime state structure for the DSPI master driver with DMA.  <a href="group__dspi__master__driver.html#structdspi__dma__master__state__t">More...</a><br/></td></tr>
<tr class="separator:structdspi__dma__master__state__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structdspi__dma__master__user__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#structdspi__dma__master__user__config__t">dspi_dma_master_user_config_t</a></td></tr>
<tr class="memdesc:structdspi__dma__master__user__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user configuration structure for the DSPI master driver with DMA.  <a href="group__dspi__master__driver.html#structdspi__dma__master__user__config__t">More...</a><br/></td></tr>
<tr class="separator:structdspi__dma__master__user__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structdspi__edma__device__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#structdspi__edma__device__t">dspi_edma_device_t</a></td></tr>
<tr class="memdesc:structdspi__edma__device__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure containing information about a device on the SPI bus with EDMA.  <a href="group__dspi__master__driver.html#structdspi__edma__device__t">More...</a><br/></td></tr>
<tr class="separator:structdspi__edma__device__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structdspi__edma__master__state__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#structdspi__edma__master__state__t">dspi_edma_master_state_t</a></td></tr>
<tr class="memdesc:structdspi__edma__master__state__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime state structure for the DSPI master driver with EDMA.  <a href="group__dspi__master__driver.html#structdspi__edma__master__state__t">More...</a><br/></td></tr>
<tr class="separator:structdspi__edma__master__state__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structdspi__edma__master__user__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#structdspi__edma__master__user__config__t">dspi_edma_master_user_config_t</a></td></tr>
<tr class="memdesc:structdspi__edma__master__user__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user configuration structure for the DSPI master driver with EDMA.  <a href="group__dspi__master__driver.html#structdspi__edma__master__user__config__t">More...</a><br/></td></tr>
<tr class="separator:structdspi__edma__master__user__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structdspi__device__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#structdspi__device__t">dspi_device_t</a></td></tr>
<tr class="memdesc:structdspi__device__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure containing information about a device on the SPI bus.  <a href="group__dspi__master__driver.html#structdspi__device__t">More...</a><br/></td></tr>
<tr class="separator:structdspi__device__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structdspi__master__state__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#structdspi__master__state__t">dspi_master_state_t</a></td></tr>
<tr class="memdesc:structdspi__master__state__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime state structure for the DSPI master driver.  <a href="group__dspi__master__driver.html#structdspi__master__state__t">More...</a><br/></td></tr>
<tr class="separator:structdspi__master__state__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structdspi__master__user__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#structdspi__master__user__config__t">dspi_master_user_config_t</a></td></tr>
<tr class="memdesc:structdspi__master__user__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user configuration structure for the DSPI master driver.  <a href="group__dspi__master__driver.html#structdspi__master__user__config__t">More...</a><br/></td></tr>
<tr class="separator:structdspi__master__user__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga19a374f8af816ac684016ad76f4c5475"><td class="memItemLeft" align="right" valign="top">SPI_Type *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga19a374f8af816ac684016ad76f4c5475">g_dspiBase</a> [SPI_INSTANCE_COUNT]</td></tr>
<tr class="memdesc:ga19a374f8af816ac684016ad76f4c5475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of base pointers for SPI instances.  <a href="#ga19a374f8af816ac684016ad76f4c5475">More...</a><br/></td></tr>
<tr class="separator:ga19a374f8af816ac684016ad76f4c5475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac730f6d2d81a79859583832ea33d61c0"><td class="memItemLeft" align="right" valign="top">const IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#gac730f6d2d81a79859583832ea33d61c0">g_dspiIrqId</a> [SPI_INSTANCE_COUNT]</td></tr>
<tr class="memdesc:gac730f6d2d81a79859583832ea33d61c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table to save DSPI IRQ enumeration numbers defined in the CMSIS header file.  <a href="#gac730f6d2d81a79859583832ea33d61c0">More...</a><br/></td></tr>
<tr class="separator:gac730f6d2d81a79859583832ea33d61c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a374f8af816ac684016ad76f4c5475"><td class="memItemLeft" align="right" valign="top">SPI_Type *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga19a374f8af816ac684016ad76f4c5475">g_dspiBase</a> [SPI_INSTANCE_COUNT]</td></tr>
<tr class="memdesc:ga19a374f8af816ac684016ad76f4c5475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of base pointers for SPI instances.  <a href="#ga19a374f8af816ac684016ad76f4c5475">More...</a><br/></td></tr>
<tr class="separator:ga19a374f8af816ac684016ad76f4c5475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac730f6d2d81a79859583832ea33d61c0"><td class="memItemLeft" align="right" valign="top">const IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#gac730f6d2d81a79859583832ea33d61c0">g_dspiIrqId</a> [SPI_INSTANCE_COUNT]</td></tr>
<tr class="memdesc:gac730f6d2d81a79859583832ea33d61c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table to save DSPI IRQ enumeration numbers defined in the CMSIS header file.  <a href="#gac730f6d2d81a79859583832ea33d61c0">More...</a><br/></td></tr>
<tr class="separator:gac730f6d2d81a79859583832ea33d61c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a374f8af816ac684016ad76f4c5475"><td class="memItemLeft" align="right" valign="top">SPI_Type *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga19a374f8af816ac684016ad76f4c5475">g_dspiBase</a> [SPI_INSTANCE_COUNT]</td></tr>
<tr class="memdesc:ga19a374f8af816ac684016ad76f4c5475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of base pointers for SPI instances.  <a href="#ga19a374f8af816ac684016ad76f4c5475">More...</a><br/></td></tr>
<tr class="separator:ga19a374f8af816ac684016ad76f4c5475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac730f6d2d81a79859583832ea33d61c0"><td class="memItemLeft" align="right" valign="top">const IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#gac730f6d2d81a79859583832ea33d61c0">g_dspiIrqId</a> [SPI_INSTANCE_COUNT]</td></tr>
<tr class="memdesc:gac730f6d2d81a79859583832ea33d61c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table to save DSPI IRQ enumeration numbers defined in the CMSIS header file.  <a href="#gac730f6d2d81a79859583832ea33d61c0">More...</a><br/></td></tr>
<tr class="separator:gac730f6d2d81a79859583832ea33d61c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Initialization and shutdown</h2></td></tr>
<tr class="memitem:ga4b9033c2680c8ca322a8fa7da213dacd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga4b9033c2680c8ca322a8fa7da213dacd">DSPI_DRV_DmaMasterInit</a> (uint32_t instance, <a class="el" href="group__dspi__master__driver.html#structdspi__dma__master__state__t">dspi_dma_master_state_t</a> *dspiDmaState, const <a class="el" href="group__dspi__master__driver.html#structdspi__dma__master__user__config__t">dspi_dma_master_user_config_t</a> *userConfig)</td></tr>
<tr class="memdesc:ga4b9033c2680c8ca322a8fa7da213dacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a DSPI instance for master mode operation to work with DMA.  <a href="#ga4b9033c2680c8ca322a8fa7da213dacd">More...</a><br/></td></tr>
<tr class="separator:ga4b9033c2680c8ca322a8fa7da213dacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92cfdcd50aa81b04c683394ba61da358"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga92cfdcd50aa81b04c683394ba61da358">DSPI_DRV_DmaMasterDeinit</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga92cfdcd50aa81b04c683394ba61da358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down a DSPI instance with the DMA support.  <a href="#ga92cfdcd50aa81b04c683394ba61da358">More...</a><br/></td></tr>
<tr class="separator:ga92cfdcd50aa81b04c683394ba61da358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17310974f56a00f4d5ef03120c629051"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga17310974f56a00f4d5ef03120c629051">DSPI_DRV_DmaMasterSetDelay</a> (uint32_t instance, <a class="el" href="group__dspi__hal.html#ga1ca2fbee37b3cb046c075a7e765d64ed">dspi_delay_type_t</a> whichDelay, uint32_t delayInNanoSec, uint32_t *calculatedDelay)</td></tr>
<tr class="memdesc:ga17310974f56a00f4d5ef03120c629051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the DSPI master mode bus timing delay options with the DMA support.  <a href="#ga17310974f56a00f4d5ef03120c629051">More...</a><br/></td></tr>
<tr class="separator:ga17310974f56a00f4d5ef03120c629051"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Bus configuration</h2></td></tr>
<tr class="memitem:ga632e7cbfcd84625a482befcb78175c08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga632e7cbfcd84625a482befcb78175c08">DSPI_DRV_DmaMasterConfigureBus</a> (uint32_t instance, const <a class="el" href="group__dspi__master__driver.html#structdspi__dma__device__t">dspi_dma_device_t</a> *device, uint32_t *calculatedBaudRate)</td></tr>
<tr class="memdesc:ga632e7cbfcd84625a482befcb78175c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the DSPI port physical parameters to access a device on the bus with the DMA support.  <a href="#ga632e7cbfcd84625a482befcb78175c08">More...</a><br/></td></tr>
<tr class="separator:ga632e7cbfcd84625a482befcb78175c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Blocking transfers</h2></td></tr>
<tr class="memitem:ga1bf6367527ef5acd3e918a5d9daf299f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga1bf6367527ef5acd3e918a5d9daf299f">DSPI_DRV_DmaMasterTransferBlocking</a> (uint32_t instance, const <a class="el" href="group__dspi__master__driver.html#structdspi__dma__device__t">dspi_dma_device_t</a> *device, const uint8_t *sendBuffer, uint8_t *receiveBuffer, size_t transferByteCount, uint32_t timeout)</td></tr>
<tr class="memdesc:ga1bf6367527ef5acd3e918a5d9daf299f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a blocking SPI master mode transfer with the DMA support.  <a href="#ga1bf6367527ef5acd3e918a5d9daf299f">More...</a><br/></td></tr>
<tr class="separator:ga1bf6367527ef5acd3e918a5d9daf299f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Non-blocking transfers</h2></td></tr>
<tr class="memitem:ga9bca76b948920da0ef56ed096fdd8c3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga9bca76b948920da0ef56ed096fdd8c3e">DSPI_DRV_DmaMasterTransfer</a> (uint32_t instance, const <a class="el" href="group__dspi__master__driver.html#structdspi__dma__device__t">dspi_dma_device_t</a> *device, const uint8_t *sendBuffer, uint8_t *receiveBuffer, size_t transferByteCount)</td></tr>
<tr class="memdesc:ga9bca76b948920da0ef56ed096fdd8c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a non-blocking SPI master mode transfer with the DMA support.  <a href="#ga9bca76b948920da0ef56ed096fdd8c3e">More...</a><br/></td></tr>
<tr class="separator:ga9bca76b948920da0ef56ed096fdd8c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga745e362e61507e5dc5d09212d131fa0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga745e362e61507e5dc5d09212d131fa0b">DSPI_DRV_DmaMasterGetTransferStatus</a> (uint32_t instance, uint32_t *framesTransferred)</td></tr>
<tr class="memdesc:ga745e362e61507e5dc5d09212d131fa0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the previous transfer is completed with the DMA support.  <a href="#ga745e362e61507e5dc5d09212d131fa0b">More...</a><br/></td></tr>
<tr class="separator:ga745e362e61507e5dc5d09212d131fa0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea95c93e0cf21a725c327606f6f5ffba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#gaea95c93e0cf21a725c327606f6f5ffba">DSPI_DRV_DmaMasterAbortTransfer</a> (uint32_t instance)</td></tr>
<tr class="memdesc:gaea95c93e0cf21a725c327606f6f5ffba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates an asynchronous transfer early with the DMA support.  <a href="#gaea95c93e0cf21a725c327606f6f5ffba">More...</a><br/></td></tr>
<tr class="separator:gaea95c93e0cf21a725c327606f6f5ffba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Initialization and shutdown</h2></td></tr>
<tr class="memitem:ga056aee779cd846ee43d4dc778f5ee6bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga056aee779cd846ee43d4dc778f5ee6bc">DSPI_DRV_EdmaMasterInit</a> (uint32_t instance, <a class="el" href="group__dspi__master__driver.html#structdspi__edma__master__state__t">dspi_edma_master_state_t</a> *dspiEdmaState, const <a class="el" href="group__dspi__master__driver.html#structdspi__edma__master__user__config__t">dspi_edma_master_user_config_t</a> *userConfig, <a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *stcdSrc2CmdDataLast)</td></tr>
<tr class="memdesc:ga056aee779cd846ee43d4dc778f5ee6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a DSPI instance for master mode operation to work with EDMA.  <a href="#ga056aee779cd846ee43d4dc778f5ee6bc">More...</a><br/></td></tr>
<tr class="separator:ga056aee779cd846ee43d4dc778f5ee6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ec2de01872d7f75a27bb68c34edc710"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga3ec2de01872d7f75a27bb68c34edc710">DSPI_DRV_EdmaMasterDeinit</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga3ec2de01872d7f75a27bb68c34edc710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down a DSPI instance with the EDMA support.  <a href="#ga3ec2de01872d7f75a27bb68c34edc710">More...</a><br/></td></tr>
<tr class="separator:ga3ec2de01872d7f75a27bb68c34edc710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga952853adf4ad08153e70b0f78cf2d926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga952853adf4ad08153e70b0f78cf2d926">DSPI_DRV_EdmaMasterSetDelay</a> (uint32_t instance, <a class="el" href="group__dspi__hal.html#ga1ca2fbee37b3cb046c075a7e765d64ed">dspi_delay_type_t</a> whichDelay, uint32_t delayInNanoSec, uint32_t *calculatedDelay)</td></tr>
<tr class="memdesc:ga952853adf4ad08153e70b0f78cf2d926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the DSPI master mode bus timing delay options with the EDMA support.  <a href="#ga952853adf4ad08153e70b0f78cf2d926">More...</a><br/></td></tr>
<tr class="separator:ga952853adf4ad08153e70b0f78cf2d926"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Bus configuration</h2></td></tr>
<tr class="memitem:ga87b4ad456a0f360cb1bb22d9c0fd3dcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga87b4ad456a0f360cb1bb22d9c0fd3dcb">DSPI_DRV_EdmaMasterConfigureBus</a> (uint32_t instance, const <a class="el" href="group__dspi__master__driver.html#structdspi__edma__device__t">dspi_edma_device_t</a> *device, uint32_t *calculatedBaudRate)</td></tr>
<tr class="memdesc:ga87b4ad456a0f360cb1bb22d9c0fd3dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the DSPI port physical parameters to access a device on the bus with the EDMA support.  <a href="#ga87b4ad456a0f360cb1bb22d9c0fd3dcb">More...</a><br/></td></tr>
<tr class="separator:ga87b4ad456a0f360cb1bb22d9c0fd3dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Blocking transfers</h2></td></tr>
<tr class="memitem:ga494b8d6379bd3879cfc7f59f7129bbf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga494b8d6379bd3879cfc7f59f7129bbf0">DSPI_DRV_EdmaMasterTransferBlocking</a> (uint32_t instance, const <a class="el" href="group__dspi__master__driver.html#structdspi__edma__device__t">dspi_edma_device_t</a> *device, const uint8_t *sendBuffer, uint8_t *receiveBuffer, size_t transferByteCount, uint32_t timeout)</td></tr>
<tr class="memdesc:ga494b8d6379bd3879cfc7f59f7129bbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a blocking SPI master mode transfer with the EDMA support.  <a href="#ga494b8d6379bd3879cfc7f59f7129bbf0">More...</a><br/></td></tr>
<tr class="separator:ga494b8d6379bd3879cfc7f59f7129bbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Non-blocking transfers</h2></td></tr>
<tr class="memitem:ga72a411c2ed35d3ae70267601c4a8115e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga72a411c2ed35d3ae70267601c4a8115e">DSPI_DRV_EdmaMasterTransfer</a> (uint32_t instance, const <a class="el" href="group__dspi__master__driver.html#structdspi__edma__device__t">dspi_edma_device_t</a> *device, const uint8_t *sendBuffer, uint8_t *receiveBuffer, size_t transferByteCount)</td></tr>
<tr class="memdesc:ga72a411c2ed35d3ae70267601c4a8115e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a non-blocking SPI master mode transfer with the EDMA support.  <a href="#ga72a411c2ed35d3ae70267601c4a8115e">More...</a><br/></td></tr>
<tr class="separator:ga72a411c2ed35d3ae70267601c4a8115e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45330690d03a2c0c249d94322141d297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga45330690d03a2c0c249d94322141d297">DSPI_DRV_EdmaMasterGetTransferStatus</a> (uint32_t instance, uint32_t *framesTransferred)</td></tr>
<tr class="memdesc:ga45330690d03a2c0c249d94322141d297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the previous transfer is completed with the EDMA support.  <a href="#ga45330690d03a2c0c249d94322141d297">More...</a><br/></td></tr>
<tr class="separator:ga45330690d03a2c0c249d94322141d297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8710c8a2abd897a2ccd4a3461fa3dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#gae8710c8a2abd897a2ccd4a3461fa3dd3">DSPI_DRV_EdmaMasterAbortTransfer</a> (uint32_t instance)</td></tr>
<tr class="memdesc:gae8710c8a2abd897a2ccd4a3461fa3dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates an asynchronous transfer early with the EDMA support.  <a href="#gae8710c8a2abd897a2ccd4a3461fa3dd3">More...</a><br/></td></tr>
<tr class="separator:gae8710c8a2abd897a2ccd4a3461fa3dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb0849778fe0d019745c3e717070fe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga4fb0849778fe0d019745c3e717070fe9">DSPI_DRV_EdmaMasterIRQHandler</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga4fb0849778fe0d019745c3e717070fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt handler for DSPI master mode.  <a href="#ga4fb0849778fe0d019745c3e717070fe9">More...</a><br/></td></tr>
<tr class="separator:ga4fb0849778fe0d019745c3e717070fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Initialization and shutdown</h2></td></tr>
<tr class="memitem:ga37d57c2ed98daaa6340d50054d617967"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga37d57c2ed98daaa6340d50054d617967">DSPI_DRV_MasterInit</a> (uint32_t instance, <a class="el" href="group__dspi__master__driver.html#structdspi__master__state__t">dspi_master_state_t</a> *dspiState, const <a class="el" href="group__dspi__master__driver.html#structdspi__master__user__config__t">dspi_master_user_config_t</a> *userConfig)</td></tr>
<tr class="memdesc:ga37d57c2ed98daaa6340d50054d617967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a DSPI instance for master mode operation.  <a href="#ga37d57c2ed98daaa6340d50054d617967">More...</a><br/></td></tr>
<tr class="separator:ga37d57c2ed98daaa6340d50054d617967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf173a42da34da0bfa391f629b8bbfd44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#gaf173a42da34da0bfa391f629b8bbfd44">DSPI_DRV_MasterDeinit</a> (uint32_t instance)</td></tr>
<tr class="memdesc:gaf173a42da34da0bfa391f629b8bbfd44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down a DSPI instance.  <a href="#gaf173a42da34da0bfa391f629b8bbfd44">More...</a><br/></td></tr>
<tr class="separator:gaf173a42da34da0bfa391f629b8bbfd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga705cfda5272cff31714e7167eed5ca7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga705cfda5272cff31714e7167eed5ca7c">DSPI_DRV_MasterSetDelay</a> (uint32_t instance, <a class="el" href="group__dspi__hal.html#ga1ca2fbee37b3cb046c075a7e765d64ed">dspi_delay_type_t</a> whichDelay, uint32_t delayInNanoSec, uint32_t *calculatedDelay)</td></tr>
<tr class="memdesc:ga705cfda5272cff31714e7167eed5ca7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the DSPI master mode bus timing delay options.  <a href="#ga705cfda5272cff31714e7167eed5ca7c">More...</a><br/></td></tr>
<tr class="separator:ga705cfda5272cff31714e7167eed5ca7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Bus configuration</h2></td></tr>
<tr class="memitem:ga484ec4f6557a5f8aa3dffa4dfc7b3ba0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga484ec4f6557a5f8aa3dffa4dfc7b3ba0">DSPI_DRV_MasterConfigureBus</a> (uint32_t instance, const <a class="el" href="group__dspi__master__driver.html#structdspi__device__t">dspi_device_t</a> *device, uint32_t *calculatedBaudRate)</td></tr>
<tr class="memdesc:ga484ec4f6557a5f8aa3dffa4dfc7b3ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the DSPI port physical parameters to access a device on the bus.  <a href="#ga484ec4f6557a5f8aa3dffa4dfc7b3ba0">More...</a><br/></td></tr>
<tr class="separator:ga484ec4f6557a5f8aa3dffa4dfc7b3ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Blocking transfers</h2></td></tr>
<tr class="memitem:gad4a5101fdb19f5b242f1ad06d9c93b4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#gad4a5101fdb19f5b242f1ad06d9c93b4e">DSPI_DRV_MasterTransferBlocking</a> (uint32_t instance, const <a class="el" href="group__dspi__master__driver.html#structdspi__device__t">dspi_device_t</a> *device, const uint8_t *sendBuffer, uint8_t *receiveBuffer, size_t transferByteCount, uint32_t timeout)</td></tr>
<tr class="memdesc:gad4a5101fdb19f5b242f1ad06d9c93b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a blocking SPI master mode transfer.  <a href="#gad4a5101fdb19f5b242f1ad06d9c93b4e">More...</a><br/></td></tr>
<tr class="separator:gad4a5101fdb19f5b242f1ad06d9c93b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Non-blocking transfers</h2></td></tr>
<tr class="memitem:ga2d475636c45ae6f0f2bced51deb37487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga2d475636c45ae6f0f2bced51deb37487">DSPI_DRV_MasterTransfer</a> (uint32_t instance, const <a class="el" href="group__dspi__master__driver.html#structdspi__device__t">dspi_device_t</a> *device, const uint8_t *sendBuffer, uint8_t *receiveBuffer, size_t transferByteCount)</td></tr>
<tr class="memdesc:ga2d475636c45ae6f0f2bced51deb37487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a non-blocking SPI master mode transfer.  <a href="#ga2d475636c45ae6f0f2bced51deb37487">More...</a><br/></td></tr>
<tr class="separator:ga2d475636c45ae6f0f2bced51deb37487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c962f4f1d462d30d275c52f118d04c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga4c962f4f1d462d30d275c52f118d04c5">DSPI_DRV_MasterGetTransferStatus</a> (uint32_t instance, uint32_t *framesTransferred)</td></tr>
<tr class="memdesc:ga4c962f4f1d462d30d275c52f118d04c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the previous transfer is completed.  <a href="#ga4c962f4f1d462d30d275c52f118d04c5">More...</a><br/></td></tr>
<tr class="separator:ga4c962f4f1d462d30d275c52f118d04c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ca2ffc48f8a7fe72694571e067b5a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ga08ca2ffc48f8a7fe72694571e067b5a1">DSPI_DRV_MasterAbortTransfer</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga08ca2ffc48f8a7fe72694571e067b5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates an asynchronous transfer early.  <a href="#ga08ca2ffc48f8a7fe72694571e067b5a1">More...</a><br/></td></tr>
<tr class="separator:ga08ca2ffc48f8a7fe72694571e067b5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf2594a27099e24b50c209d401910efe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#gacf2594a27099e24b50c209d401910efe">DSPI_DRV_MasterIRQHandler</a> (uint32_t instance)</td></tr>
<tr class="memdesc:gacf2594a27099e24b50c209d401910efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt handler for DSPI master mode.  <a href="#gacf2594a27099e24b50c209d401910efe">More...</a><br/></td></tr>
<tr class="separator:gacf2594a27099e24b50c209d401910efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structdspi__dma__device__t" id="structdspi__dma__device__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dspi_dma_device_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The user must populate the members to set up the DSPI master with DMA and properly communicate with the SPI device. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a8a1f0a877df8f0b1536f7ac287ce9a98"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a8a1f0a877df8f0b1536f7ac287ce9a98">bitsPerSec</a></td></tr>
<tr class="memdesc:a8a1f0a877df8f0b1536f7ac287ce9a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Baud rate in bits per second.  <a href="#a8a1f0a877df8f0b1536f7ac287ce9a98">More...</a><br/></td></tr>
<tr class="separator:a8a1f0a877df8f0b1536f7ac287ce9a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a8a1f0a877df8f0b1536f7ac287ce9a98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dspi_dma_device_t::bitsPerSec</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structdspi__dma__master__state__t" id="structdspi__dma__master__state__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dspi_dma_master_state_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure holds data used by the DSPI master Peripheral driver to communicate between the transfer function and the interrupt handler. The interrupt handler also uses this information to keep track of its progress. The user passes the memory for this run-time state structure. The DSPI master driver populates the members. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a1af5a11c0b033ed37caa8ad8078c943d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1af5a11c0b033ed37caa8ad8078c943d"></a>
<a class="el" href="group__dspi__hal.html#ga992d5562af4cf4c45371feb8c5c1a1bf">dspi_ctar_selection_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a1af5a11c0b033ed37caa8ad8078c943d">whichCtar</a></td></tr>
<tr class="memdesc:a1af5a11c0b033ed37caa8ad8078c943d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired Clock and Transfer Attributes Register (CTAR) <br/></td></tr>
<tr class="separator:a1af5a11c0b033ed37caa8ad8078c943d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0632c90c99e9dcc5cdc4337c0d3f8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f0632c90c99e9dcc5cdc4337c0d3f8c"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a4f0632c90c99e9dcc5cdc4337c0d3f8c">bitsPerFrame</a></td></tr>
<tr class="memdesc:a4f0632c90c99e9dcc5cdc4337c0d3f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired number of bits per frame. <br/></td></tr>
<tr class="separator:a4f0632c90c99e9dcc5cdc4337c0d3f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4e63d88d1445d4287f85a63bf7c2e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa4e63d88d1445d4287f85a63bf7c2e5"></a>
<a class="el" href="group__dspi__hal.html#ga3d9d9a8fe16a51e6c697a547ab65bef1">dspi_which_pcs_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#afa4e63d88d1445d4287f85a63bf7c2e5">whichPcs</a></td></tr>
<tr class="memdesc:afa4e63d88d1445d4287f85a63bf7c2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired Peripheral Chip Select (pcs) <br/></td></tr>
<tr class="separator:afa4e63d88d1445d4287f85a63bf7c2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e8953820579d2451dbc299be6f71af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45e8953820579d2451dbc299be6f71af"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a45e8953820579d2451dbc299be6f71af">isChipSelectContinuous</a></td></tr>
<tr class="memdesc:a45e8953820579d2451dbc299be6f71af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option to enable the continuous assertion of chip select between transfers. <br/></td></tr>
<tr class="separator:a45e8953820579d2451dbc299be6f71af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c528fc09bfc554f8c04c547323def9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6c528fc09bfc554f8c04c547323def9"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ab6c528fc09bfc554f8c04c547323def9">dspiSourceClock</a></td></tr>
<tr class="memdesc:ab6c528fc09bfc554f8c04c547323def9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module source clock. <br/></td></tr>
<tr class="separator:ab6c528fc09bfc554f8c04c547323def9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2840a225e526d860fa8c57a9182f28"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a7a2840a225e526d860fa8c57a9182f28">isTransferInProgress</a></td></tr>
<tr class="memdesc:a7a2840a225e526d860fa8c57a9182f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if there is an active transfer.  <a href="#a7a2840a225e526d860fa8c57a9182f28">More...</a><br/></td></tr>
<tr class="separator:a7a2840a225e526d860fa8c57a9182f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2c5edb36e7bfbb384073bc6858af4d"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#aac2c5edb36e7bfbb384073bc6858af4d">isTransferBlocking</a></td></tr>
<tr class="memdesc:aac2c5edb36e7bfbb384073bc6858af4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if transfer is a blocking transaction.  <a href="#aac2c5edb36e7bfbb384073bc6858af4d">More...</a><br/></td></tr>
<tr class="separator:aac2c5edb36e7bfbb384073bc6858af4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0826a2453b95136d03e714ac07e2f2e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__os__abstraction__bm.html#structsemaphore__t">semaphore_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a0826a2453b95136d03e714ac07e2f2e9">irqSync</a></td></tr>
<tr class="memdesc:a0826a2453b95136d03e714ac07e2f2e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to wait for ISR to complete its business.  <a href="#a0826a2453b95136d03e714ac07e2f2e9">More...</a><br/></td></tr>
<tr class="separator:a0826a2453b95136d03e714ac07e2f2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c689b62461af0806fca33d33ee89c72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c689b62461af0806fca33d33ee89c72"></a>
<a class="el" href="group__dma__driver.html#structdma__channel__t">dma_channel_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a5c689b62461af0806fca33d33ee89c72">dmaTxDataChannel</a></td></tr>
<tr class="memdesc:a5c689b62461af0806fca33d33ee89c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure definition for the DMA channel. <br/></td></tr>
<tr class="separator:a5c689b62461af0806fca33d33ee89c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d75144ec73d554779b976889a444d57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d75144ec73d554779b976889a444d57"></a>
<a class="el" href="group__dma__driver.html#structdma__channel__t">dma_channel_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a3d75144ec73d554779b976889a444d57">dmaTxCmdChannel</a></td></tr>
<tr class="memdesc:a3d75144ec73d554779b976889a444d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure definition for the DMA channel. <br/></td></tr>
<tr class="separator:a3d75144ec73d554779b976889a444d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1643f079a0733fb1d0e08ac53e6f6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b1643f079a0733fb1d0e08ac53e6f6f"></a>
<a class="el" href="group__dma__driver.html#structdma__channel__t">dma_channel_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a0b1643f079a0733fb1d0e08ac53e6f6f">dmaRxChannel</a></td></tr>
<tr class="memdesc:a0b1643f079a0733fb1d0e08ac53e6f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure definition for the DMA channel. <br/></td></tr>
<tr class="separator:a0b1643f079a0733fb1d0e08ac53e6f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10a8847163e4116aed3a51fc297b84a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af10a8847163e4116aed3a51fc297b84a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#af10a8847163e4116aed3a51fc297b84a">extraByte</a></td></tr>
<tr class="memdesc:af10a8847163e4116aed3a51fc297b84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag used for 16-bit transfers with odd byte count. <br/></td></tr>
<tr class="separator:af10a8847163e4116aed3a51fc297b84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06672f89b84663f6e9869864583a89a"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ad06672f89b84663f6e9869864583a89a">rxBuffer</a></td></tr>
<tr class="memdesc:ad06672f89b84663f6e9869864583a89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer into which received bytes are placed.  <a href="#ad06672f89b84663f6e9869864583a89a">More...</a><br/></td></tr>
<tr class="separator:ad06672f89b84663f6e9869864583a89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15d6e3ed04e98a9d05eed528e9ee152"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ae15d6e3ed04e98a9d05eed528e9ee152">rxTransferByteCnt</a></td></tr>
<tr class="memdesc:ae15d6e3ed04e98a9d05eed528e9ee152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes to receive.  <a href="#ae15d6e3ed04e98a9d05eed528e9ee152">More...</a><br/></td></tr>
<tr class="separator:ae15d6e3ed04e98a9d05eed528e9ee152"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a7a2840a225e526d860fa8c57a9182f28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool dspi_dma_master_state_t::isTransferInProgress</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aac2c5edb36e7bfbb384073bc6858af4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool dspi_dma_master_state_t::isTransferBlocking</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0826a2453b95136d03e714ac07e2f2e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__os__abstraction__bm.html#structsemaphore__t">semaphore_t</a> dspi_dma_master_state_t::irqSync</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad06672f89b84663f6e9869864583a89a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* dspi_dma_master_state_t::rxBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae15d6e3ed04e98a9d05eed528e9ee152"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dspi_dma_master_state_t::rxTransferByteCnt</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structdspi__dma__master__user__config__t" id="structdspi__dma__master__user__config__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dspi_dma_master_user_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Use an instance of this structure with the <a class="el" href="group__dspi__master__driver.html#ga4b9033c2680c8ca322a8fa7da213dacd" title="Initializes a DSPI instance for master mode operation to work with DMA. ">DSPI_DRV_DmaMasterInit()</a> function. This allows the user to configure the most common settings of the DSPI peripheral with a single function call. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a6902667c509d25ff7ba1ce653cf95b6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6902667c509d25ff7ba1ce653cf95b6b"></a>
<a class="el" href="group__dspi__hal.html#ga992d5562af4cf4c45371feb8c5c1a1bf">dspi_ctar_selection_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a6902667c509d25ff7ba1ce653cf95b6b">whichCtar</a></td></tr>
<tr class="memdesc:a6902667c509d25ff7ba1ce653cf95b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired Clock and Transfer Attributes Register(CTAR) <br/></td></tr>
<tr class="separator:a6902667c509d25ff7ba1ce653cf95b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae666bfad790536b377253ab05ff0d4d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae666bfad790536b377253ab05ff0d4d7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ae666bfad790536b377253ab05ff0d4d7">isSckContinuous</a></td></tr>
<tr class="memdesc:ae666bfad790536b377253ab05ff0d4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable or Enable continuous SCK operation. <br/></td></tr>
<tr class="separator:ae666bfad790536b377253ab05ff0d4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96cb961f4e8f554faa41bb73b8a3cc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa96cb961f4e8f554faa41bb73b8a3cc0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#aa96cb961f4e8f554faa41bb73b8a3cc0">isChipSelectContinuous</a></td></tr>
<tr class="memdesc:aa96cb961f4e8f554faa41bb73b8a3cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option to enable the continuous assertion of chip select between transfers. <br/></td></tr>
<tr class="separator:aa96cb961f4e8f554faa41bb73b8a3cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204f253a8dd479f849cd75713d36d8d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a204f253a8dd479f849cd75713d36d8d9"></a>
<a class="el" href="group__dspi__hal.html#ga3d9d9a8fe16a51e6c697a547ab65bef1">dspi_which_pcs_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a204f253a8dd479f849cd75713d36d8d9">whichPcs</a></td></tr>
<tr class="memdesc:a204f253a8dd479f849cd75713d36d8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired Peripheral Chip Select (pcs) <br/></td></tr>
<tr class="separator:a204f253a8dd479f849cd75713d36d8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f7ef97c45f8ce27e8fc572902a4406"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#gab466e73cb54b2c023459d43918c4197d">dspi_pcs_polarity_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a03f7ef97c45f8ce27e8fc572902a4406">pcsPolarity</a></td></tr>
<tr class="memdesc:a03f7ef97c45f8ce27e8fc572902a4406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peripheral Chip Select (pcs) polarity setting.  <a href="#a03f7ef97c45f8ce27e8fc572902a4406">More...</a><br/></td></tr>
<tr class="separator:a03f7ef97c45f8ce27e8fc572902a4406"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a03f7ef97c45f8ce27e8fc572902a4406"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#gab466e73cb54b2c023459d43918c4197d">dspi_pcs_polarity_config_t</a> dspi_dma_master_user_config_t::pcsPolarity</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structdspi__edma__device__t" id="structdspi__edma__device__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dspi_edma_device_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The user must populate the members to set up the DSPI master with EDMA and properly communicate with the SPI device. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a11c692151d0c51699d2818c4dc9ff29a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a11c692151d0c51699d2818c4dc9ff29a">bitsPerSec</a></td></tr>
<tr class="memdesc:a11c692151d0c51699d2818c4dc9ff29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Baud rate in bits per second.  <a href="#a11c692151d0c51699d2818c4dc9ff29a">More...</a><br/></td></tr>
<tr class="separator:a11c692151d0c51699d2818c4dc9ff29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a11c692151d0c51699d2818c4dc9ff29a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dspi_edma_device_t::bitsPerSec</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structdspi__edma__master__state__t" id="structdspi__edma__master__state__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dspi_edma_master_state_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure holds data used by the DSPI master Peripheral driver to communicate between the transfer function and the interrupt handler. The interrupt handler also uses this information to keep track of its progress. The user passes the memory for this run-time state structure. The DSPI master driver populates the members. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a9d8586e95f2f076ad7e2fcdf803baae7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d8586e95f2f076ad7e2fcdf803baae7"></a>
<a class="el" href="group__dspi__hal.html#ga992d5562af4cf4c45371feb8c5c1a1bf">dspi_ctar_selection_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a9d8586e95f2f076ad7e2fcdf803baae7">whichCtar</a></td></tr>
<tr class="memdesc:a9d8586e95f2f076ad7e2fcdf803baae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired Clock and Transfer Attributes Register (CTAR) <br/></td></tr>
<tr class="separator:a9d8586e95f2f076ad7e2fcdf803baae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675148ed22081f880ea60b9f0dd4fa9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a675148ed22081f880ea60b9f0dd4fa9d"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a675148ed22081f880ea60b9f0dd4fa9d">bitsPerFrame</a></td></tr>
<tr class="memdesc:a675148ed22081f880ea60b9f0dd4fa9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired number of bits per frame. <br/></td></tr>
<tr class="separator:a675148ed22081f880ea60b9f0dd4fa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47283586a1c5c74bbdd60bd414a1b1d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47283586a1c5c74bbdd60bd414a1b1d4"></a>
<a class="el" href="group__dspi__hal.html#ga3d9d9a8fe16a51e6c697a547ab65bef1">dspi_which_pcs_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a47283586a1c5c74bbdd60bd414a1b1d4">whichPcs</a></td></tr>
<tr class="memdesc:a47283586a1c5c74bbdd60bd414a1b1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired Peripheral Chip Select (pcs) <br/></td></tr>
<tr class="separator:a47283586a1c5c74bbdd60bd414a1b1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0c791c50fc7acdf8b96637a9018b87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c0c791c50fc7acdf8b96637a9018b87"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a9c0c791c50fc7acdf8b96637a9018b87">isChipSelectContinuous</a></td></tr>
<tr class="memdesc:a9c0c791c50fc7acdf8b96637a9018b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option to enable the continuous assertion of chip select between transfers. <br/></td></tr>
<tr class="separator:a9c0c791c50fc7acdf8b96637a9018b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580eef13384b25fe49e545b48bcb21b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a580eef13384b25fe49e545b48bcb21b3"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a580eef13384b25fe49e545b48bcb21b3">dspiSourceClock</a></td></tr>
<tr class="memdesc:a580eef13384b25fe49e545b48bcb21b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module source clock. <br/></td></tr>
<tr class="separator:a580eef13384b25fe49e545b48bcb21b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca5667b5af07785677d8f325c2ccea3"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a0ca5667b5af07785677d8f325c2ccea3">isTransferInProgress</a></td></tr>
<tr class="memdesc:a0ca5667b5af07785677d8f325c2ccea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if there is an active transfer.  <a href="#a0ca5667b5af07785677d8f325c2ccea3">More...</a><br/></td></tr>
<tr class="separator:a0ca5667b5af07785677d8f325c2ccea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f81ee2f9a605096fb0b6fb5cb520a8"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a45f81ee2f9a605096fb0b6fb5cb520a8">isTransferBlocking</a></td></tr>
<tr class="memdesc:a45f81ee2f9a605096fb0b6fb5cb520a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if transfer is a blocking transaction.  <a href="#a45f81ee2f9a605096fb0b6fb5cb520a8">More...</a><br/></td></tr>
<tr class="separator:a45f81ee2f9a605096fb0b6fb5cb520a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dd232e32daddc81cc73a8067dbb87c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__os__abstraction__bm.html#structsemaphore__t">semaphore_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a38dd232e32daddc81cc73a8067dbb87c">irqSync</a></td></tr>
<tr class="memdesc:a38dd232e32daddc81cc73a8067dbb87c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to wait for ISR to complete its business.  <a href="#a38dd232e32daddc81cc73a8067dbb87c">More...</a><br/></td></tr>
<tr class="separator:a38dd232e32daddc81cc73a8067dbb87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2860401eb7fd6f740860bb21717169"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca2860401eb7fd6f740860bb21717169"></a>
<a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#aca2860401eb7fd6f740860bb21717169">dmaCmdData2Fifo</a></td></tr>
<tr class="memdesc:aca2860401eb7fd6f740860bb21717169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure definition for the eDMA channel. <br/></td></tr>
<tr class="separator:aca2860401eb7fd6f740860bb21717169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cf84c76106719e511a99b6d94cd0f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5cf84c76106719e511a99b6d94cd0f3"></a>
<a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ab5cf84c76106719e511a99b6d94cd0f3">dmaSrc2CmdData</a></td></tr>
<tr class="memdesc:ab5cf84c76106719e511a99b6d94cd0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure definition for the eDMA channel. <br/></td></tr>
<tr class="separator:ab5cf84c76106719e511a99b6d94cd0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0379ea8033305a1abf4e4b68841571c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0379ea8033305a1abf4e4b68841571c7"></a>
<a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a0379ea8033305a1abf4e4b68841571c7">dmaFifo2Receive</a></td></tr>
<tr class="memdesc:a0379ea8033305a1abf4e4b68841571c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure definition for the eDMA channel. <br/></td></tr>
<tr class="separator:a0379ea8033305a1abf4e4b68841571c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111917d3b5d1c7746a058b877069bf5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a111917d3b5d1c7746a058b877069bf5c"></a>
<a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a111917d3b5d1c7746a058b877069bf5c">stcdSrc2CmdDataLast</a></td></tr>
<tr class="memdesc:a111917d3b5d1c7746a058b877069bf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to SW TCD in memory. <br/></td></tr>
<tr class="separator:a111917d3b5d1c7746a058b877069bf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3a096a1d3f637d119951d50a376b86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c3a096a1d3f637d119951d50a376b86"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a9c3a096a1d3f637d119951d50a376b86">extraByte</a></td></tr>
<tr class="memdesc:a9c3a096a1d3f637d119951d50a376b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag used for 16-bit transfers with odd byte count. <br/></td></tr>
<tr class="separator:a9c3a096a1d3f637d119951d50a376b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ee781c98a0e16bee6362cf6a84651a"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a56ee781c98a0e16bee6362cf6a84651a">rxBuffer</a></td></tr>
<tr class="memdesc:a56ee781c98a0e16bee6362cf6a84651a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer into which received bytes are placed.  <a href="#a56ee781c98a0e16bee6362cf6a84651a">More...</a><br/></td></tr>
<tr class="separator:a56ee781c98a0e16bee6362cf6a84651a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bb61e54c98b12b2088a8da3bc7ea21"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ac7bb61e54c98b12b2088a8da3bc7ea21">rxTransferByteCnt</a></td></tr>
<tr class="memdesc:ac7bb61e54c98b12b2088a8da3bc7ea21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes to receive.  <a href="#ac7bb61e54c98b12b2088a8da3bc7ea21">More...</a><br/></td></tr>
<tr class="separator:ac7bb61e54c98b12b2088a8da3bc7ea21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a0ca5667b5af07785677d8f325c2ccea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool dspi_edma_master_state_t::isTransferInProgress</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a45f81ee2f9a605096fb0b6fb5cb520a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool dspi_edma_master_state_t::isTransferBlocking</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a38dd232e32daddc81cc73a8067dbb87c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__os__abstraction__bm.html#structsemaphore__t">semaphore_t</a> dspi_edma_master_state_t::irqSync</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a56ee781c98a0e16bee6362cf6a84651a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* dspi_edma_master_state_t::rxBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac7bb61e54c98b12b2088a8da3bc7ea21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dspi_edma_master_state_t::rxTransferByteCnt</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structdspi__edma__master__user__config__t" id="structdspi__edma__master__user__config__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dspi_edma_master_user_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Use an instance of this structure with the <a class="el" href="group__dspi__master__driver.html#ga056aee779cd846ee43d4dc778f5ee6bc" title="Initializes a DSPI instance for master mode operation to work with EDMA. ">DSPI_DRV_EdmaMasterInit()</a> function. This allows the user to configure the most common settings of the DSPI peripheral with a single function call. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a9a44b97547b785015cf8383d4c5a43c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a44b97547b785015cf8383d4c5a43c9"></a>
<a class="el" href="group__dspi__hal.html#ga992d5562af4cf4c45371feb8c5c1a1bf">dspi_ctar_selection_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a9a44b97547b785015cf8383d4c5a43c9">whichCtar</a></td></tr>
<tr class="memdesc:a9a44b97547b785015cf8383d4c5a43c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired Clock and Transfer Attributes Register(CTAR) <br/></td></tr>
<tr class="separator:a9a44b97547b785015cf8383d4c5a43c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07a5d781ecdd79c5615264c24654726"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af07a5d781ecdd79c5615264c24654726"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#af07a5d781ecdd79c5615264c24654726">isSckContinuous</a></td></tr>
<tr class="memdesc:af07a5d781ecdd79c5615264c24654726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable or Enable continuous SCK operation. <br/></td></tr>
<tr class="separator:af07a5d781ecdd79c5615264c24654726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fd49026678919882db3f457aef07da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48fd49026678919882db3f457aef07da"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a48fd49026678919882db3f457aef07da">isChipSelectContinuous</a></td></tr>
<tr class="memdesc:a48fd49026678919882db3f457aef07da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option to enable the continuous assertion of chip select between transfers. <br/></td></tr>
<tr class="separator:a48fd49026678919882db3f457aef07da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd1f1c44dd7177a070d08e2884ef1d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfd1f1c44dd7177a070d08e2884ef1d1"></a>
<a class="el" href="group__dspi__hal.html#ga3d9d9a8fe16a51e6c697a547ab65bef1">dspi_which_pcs_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#abfd1f1c44dd7177a070d08e2884ef1d1">whichPcs</a></td></tr>
<tr class="memdesc:abfd1f1c44dd7177a070d08e2884ef1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired Peripheral Chip Select (pcs) <br/></td></tr>
<tr class="separator:abfd1f1c44dd7177a070d08e2884ef1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e98667e6269f6138154852b1bc9a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dspi__hal.html#gab466e73cb54b2c023459d43918c4197d">dspi_pcs_polarity_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ad0e98667e6269f6138154852b1bc9a99">pcsPolarity</a></td></tr>
<tr class="memdesc:ad0e98667e6269f6138154852b1bc9a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peripheral Chip Select (pcs) polarity setting.  <a href="#ad0e98667e6269f6138154852b1bc9a99">More...</a><br/></td></tr>
<tr class="separator:ad0e98667e6269f6138154852b1bc9a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="ad0e98667e6269f6138154852b1bc9a99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#gab466e73cb54b2c023459d43918c4197d">dspi_pcs_polarity_config_t</a> dspi_edma_master_user_config_t::pcsPolarity</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structdspi__device__t" id="structdspi__device__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dspi_device_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The user must populate these members to set up the DSPI master and properly communicate with the SPI device. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:ac497d381e4bb407f8968ad34c47e7abd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ac497d381e4bb407f8968ad34c47e7abd">bitsPerSec</a></td></tr>
<tr class="memdesc:ac497d381e4bb407f8968ad34c47e7abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Baud rate in bits per second.  <a href="#ac497d381e4bb407f8968ad34c47e7abd">More...</a><br/></td></tr>
<tr class="separator:ac497d381e4bb407f8968ad34c47e7abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="ac497d381e4bb407f8968ad34c47e7abd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dspi_device_t::bitsPerSec</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structdspi__master__state__t" id="structdspi__master__state__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dspi_master_state_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure holds data that is used by the DSPI master peripheral driver to communicate between the transfer function and the interrupt handler. The interrupt handler also uses this information to keep track of its progress. The user must pass the memory for this run-time state structure. The DSPI master driver populates the members. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a8447aa1f8e3c7a042f6067d5db229b3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8447aa1f8e3c7a042f6067d5db229b3d"></a>
<a class="el" href="group__dspi__hal.html#ga992d5562af4cf4c45371feb8c5c1a1bf">dspi_ctar_selection_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a8447aa1f8e3c7a042f6067d5db229b3d">whichCtar</a></td></tr>
<tr class="memdesc:a8447aa1f8e3c7a042f6067d5db229b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired Clock and Transfer Attributes Register (CTAR) <br/></td></tr>
<tr class="separator:a8447aa1f8e3c7a042f6067d5db229b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab807db073ddedf4b2d9501623f20a1ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab807db073ddedf4b2d9501623f20a1ce"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ab807db073ddedf4b2d9501623f20a1ce">bitsPerFrame</a></td></tr>
<tr class="memdesc:ab807db073ddedf4b2d9501623f20a1ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired number of bits per frame. <br/></td></tr>
<tr class="separator:ab807db073ddedf4b2d9501623f20a1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746431edc005d62720977114c967e3d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a746431edc005d62720977114c967e3d7"></a>
<a class="el" href="group__dspi__hal.html#ga3d9d9a8fe16a51e6c697a547ab65bef1">dspi_which_pcs_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a746431edc005d62720977114c967e3d7">whichPcs</a></td></tr>
<tr class="memdesc:a746431edc005d62720977114c967e3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired Peripheral Chip Select (pcs) <br/></td></tr>
<tr class="separator:a746431edc005d62720977114c967e3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522a8f6ed8231786eebb958cc3d6c748"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a522a8f6ed8231786eebb958cc3d6c748"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a522a8f6ed8231786eebb958cc3d6c748">isChipSelectContinuous</a></td></tr>
<tr class="memdesc:a522a8f6ed8231786eebb958cc3d6c748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option to enable the continuous assertion of chip select between transfers. <br/></td></tr>
<tr class="separator:a522a8f6ed8231786eebb958cc3d6c748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25474cfb3a0cbb6b2f29c6025de9c241"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25474cfb3a0cbb6b2f29c6025de9c241"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a25474cfb3a0cbb6b2f29c6025de9c241">dspiSourceClock</a></td></tr>
<tr class="memdesc:a25474cfb3a0cbb6b2f29c6025de9c241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module source clock. <br/></td></tr>
<tr class="separator:a25474cfb3a0cbb6b2f29c6025de9c241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ad5f35d37f7d19f933605fa33d7a33"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ae2ad5f35d37f7d19f933605fa33d7a33">isTransferInProgress</a></td></tr>
<tr class="memdesc:ae2ad5f35d37f7d19f933605fa33d7a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if there is an active transfer.  <a href="#ae2ad5f35d37f7d19f933605fa33d7a33">More...</a><br/></td></tr>
<tr class="separator:ae2ad5f35d37f7d19f933605fa33d7a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ee63c2cef493e3a2c8f49980bbfbab"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a70ee63c2cef493e3a2c8f49980bbfbab">sendBuffer</a></td></tr>
<tr class="memdesc:a70ee63c2cef493e3a2c8f49980bbfbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer from which transmitted bytes are taken.  <a href="#a70ee63c2cef493e3a2c8f49980bbfbab">More...</a><br/></td></tr>
<tr class="separator:a70ee63c2cef493e3a2c8f49980bbfbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bb65af88f20ee078660dc253155253"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a52bb65af88f20ee078660dc253155253">receiveBuffer</a></td></tr>
<tr class="memdesc:a52bb65af88f20ee078660dc253155253"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer into which received bytes are placed.  <a href="#a52bb65af88f20ee078660dc253155253">More...</a><br/></td></tr>
<tr class="separator:a52bb65af88f20ee078660dc253155253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e19eecde4dd06a2cc7b34c1afb482"><td class="memItemLeft" align="right" valign="top">volatile size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a9e4e19eecde4dd06a2cc7b34c1afb482">remainingSendByteCount</a></td></tr>
<tr class="memdesc:a9e4e19eecde4dd06a2cc7b34c1afb482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes remaining to send.  <a href="#a9e4e19eecde4dd06a2cc7b34c1afb482">More...</a><br/></td></tr>
<tr class="separator:a9e4e19eecde4dd06a2cc7b34c1afb482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0949ba24311bf711645b495aba1835bb"><td class="memItemLeft" align="right" valign="top">volatile size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a0949ba24311bf711645b495aba1835bb">remainingReceiveByteCount</a></td></tr>
<tr class="memdesc:a0949ba24311bf711645b495aba1835bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes remaining to receive.  <a href="#a0949ba24311bf711645b495aba1835bb">More...</a><br/></td></tr>
<tr class="separator:a0949ba24311bf711645b495aba1835bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93bc304d33fdfbc180352039e97a71a"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ad93bc304d33fdfbc180352039e97a71a">isTransferBlocking</a></td></tr>
<tr class="memdesc:ad93bc304d33fdfbc180352039e97a71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if transfer is a blocking transaction.  <a href="#ad93bc304d33fdfbc180352039e97a71a">More...</a><br/></td></tr>
<tr class="separator:ad93bc304d33fdfbc180352039e97a71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45498ed7c37d843bbcda3f386419dd99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__os__abstraction__bm.html#structsemaphore__t">semaphore_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a45498ed7c37d843bbcda3f386419dd99">irqSync</a></td></tr>
<tr class="memdesc:a45498ed7c37d843bbcda3f386419dd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to wait for ISR to complete its business.  <a href="#a45498ed7c37d843bbcda3f386419dd99">More...</a><br/></td></tr>
<tr class="separator:a45498ed7c37d843bbcda3f386419dd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04225d8781083cbae568ec54b19a6e07"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04225d8781083cbae568ec54b19a6e07"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a04225d8781083cbae568ec54b19a6e07">extraByte</a></td></tr>
<tr class="memdesc:a04225d8781083cbae568ec54b19a6e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag used for 16-bit transfers with odd byte count. <br/></td></tr>
<tr class="separator:a04225d8781083cbae568ec54b19a6e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="ae2ad5f35d37f7d19f933605fa33d7a33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool dspi_master_state_t::isTransferInProgress</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a70ee63c2cef493e3a2c8f49980bbfbab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* dspi_master_state_t::sendBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a52bb65af88f20ee078660dc253155253"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* dspi_master_state_t::receiveBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9e4e19eecde4dd06a2cc7b34c1afb482"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile size_t dspi_master_state_t::remainingSendByteCount</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0949ba24311bf711645b495aba1835bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile size_t dspi_master_state_t::remainingReceiveByteCount</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad93bc304d33fdfbc180352039e97a71a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool dspi_master_state_t::isTransferBlocking</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a45498ed7c37d843bbcda3f386419dd99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__os__abstraction__bm.html#structsemaphore__t">semaphore_t</a> dspi_master_state_t::irqSync</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structdspi__master__user__config__t" id="structdspi__master__user__config__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dspi_master_user_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Use an instance of this structure with the <a class="el" href="group__dspi__master__driver.html#ga37d57c2ed98daaa6340d50054d617967" title="Initializes a DSPI instance for master mode operation. ">DSPI_DRV_MasterInit()</a> function. This allows the user to configure the most common settings of the DSPI peripheral with a single function call. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a8514df82b4b4c68f4de58a3ed160faf1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8514df82b4b4c68f4de58a3ed160faf1"></a>
<a class="el" href="group__dspi__hal.html#ga992d5562af4cf4c45371feb8c5c1a1bf">dspi_ctar_selection_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a8514df82b4b4c68f4de58a3ed160faf1">whichCtar</a></td></tr>
<tr class="memdesc:a8514df82b4b4c68f4de58a3ed160faf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired Clock and Transfer Attributes Register(CTAR) <br/></td></tr>
<tr class="separator:a8514df82b4b4c68f4de58a3ed160faf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c46d04d4031ebb56a12c665a0d17aaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c46d04d4031ebb56a12c665a0d17aaa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a6c46d04d4031ebb56a12c665a0d17aaa">isSckContinuous</a></td></tr>
<tr class="memdesc:a6c46d04d4031ebb56a12c665a0d17aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable or Enable continuous SCK operation. <br/></td></tr>
<tr class="separator:a6c46d04d4031ebb56a12c665a0d17aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9c810904ee8e24abefb25b9045c125"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada9c810904ee8e24abefb25b9045c125"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#ada9c810904ee8e24abefb25b9045c125">isChipSelectContinuous</a></td></tr>
<tr class="memdesc:ada9c810904ee8e24abefb25b9045c125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option to enable the continuous assertion of chip select between transfers. <br/></td></tr>
<tr class="separator:ada9c810904ee8e24abefb25b9045c125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6433c1800d2a85da45ae347022c3cd9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6433c1800d2a85da45ae347022c3cd9b"></a>
<a class="el" href="group__dspi__hal.html#ga3d9d9a8fe16a51e6c697a547ab65bef1">dspi_which_pcs_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#a6433c1800d2a85da45ae347022c3cd9b">whichPcs</a></td></tr>
<tr class="memdesc:a6433c1800d2a85da45ae347022c3cd9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired Peripheral Chip Select (pcs) <br/></td></tr>
<tr class="separator:a6433c1800d2a85da45ae347022c3cd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b1f2458668337b90a340a4ecaf4aa4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8b1f2458668337b90a340a4ecaf4aa4"></a>
<a class="el" href="group__dspi__hal.html#gab466e73cb54b2c023459d43918c4197d">dspi_pcs_polarity_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspi__master__driver.html#aa8b1f2458668337b90a340a4ecaf4aa4">pcsPolarity</a></td></tr>
<tr class="memdesc:aa8b1f2458668337b90a340a4ecaf4aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peripheral Chip Select (pcs) polarity setting. <br/></td></tr>
<tr class="separator:aa8b1f2458668337b90a340a4ecaf4aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga4b9033c2680c8ca322a8fa7da213dacd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_DmaMasterInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dspi__master__driver.html#structdspi__dma__master__state__t">dspi_dma_master_state_t</a> *&#160;</td>
          <td class="paramname"><em>dspiDmaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__dspi__master__driver.html#structdspi__dma__master__user__config__t">dspi_dma_master_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>userConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function uses a DMA-driven method for transferring data. This function initializes the run-time state structure to track the ongoing transfers, ungates the clock to the DSPI module, resets the DSPI module, initializes the module to user-defined settings and default settings, configures the IRQ state structure, enables the module-level interrupt to the core, and enables the DSPI module. The CTAR parameter is special in that it allows the user to have different SPI devices connected to the same DSPI module instance in addition to different peripheral chip selects. Each CTAR contains the bus attributes associated with that particular SPI device. For most use cases, where only one SPI device is connected per DSPI module instance, use CTAR0. This is an example to set up and call the DSPI_DRV_DmaMasterInit function by passing in these parameters: </p>
<div class="fragment"><div class="line"><a class="code" href="group__dspi__master__driver.html#structdspi__dma__master__state__t">dspi_dma_master_state_t</a> dspiDmaState; &lt;- the user allocates memory <span class="keywordflow">for</span> <span class="keyword">this</span> structure</div>
<div class="line">uint32_t calculatedBaudRate;</div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#structdspi__dma__master__user__config__t">dspi_dma_master_user_config_t</a> userConfig; &lt;- the user populates members <span class="keywordflow">for</span> <span class="keyword">this</span> structure</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#aa96cb961f4e8f554faa41bb73b8a3cc0">isChipSelectContinuous</a> = <span class="keyword">false</span>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#ae666bfad790536b377253ab05ff0d4d7">isSckContinuous</a> = <span class="keyword">false</span>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#a03f7ef97c45f8ce27e8fc572902a4406">pcsPolarity</a> = <a class="code" href="group__dspi__hal.html#ggab466e73cb54b2c023459d43918c4197daf89a174f7da2c2d1dd94eaee5f451ac7">kDspiPcs_ActiveLow</a>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#a6902667c509d25ff7ba1ce653cf95b6b">whichCtar</a> = <a class="code" href="group__dspi__hal.html#gga992d5562af4cf4c45371feb8c5c1a1bfa21d94da5d7c4e6134907fad358147b35">kDspiCtar0</a>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#a204f253a8dd479f849cd75713d36d8d9">whichPcs</a> = <a class="code" href="group__dspi__hal.html#gga3d9d9a8fe16a51e6c697a547ab65bef1abf98b398d467bec5ce1332e7769b9c97">kDspiPcs0</a>;</div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga4b9033c2680c8ca322a8fa7da213dacd">DSPI_DRV_DmaMasterInit</a>(masterInstance, &amp;dspiDmaState, &amp;userConfig);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">dspiDmaState</td><td>The pointer to the DSPI DMA master driver state structure. The user passes the memory for the run-time state structure. The DSPI master driver populates the members. The run-time state structure keeps track of the transfer in progress. </td></tr>
    <tr><td class="paramname">userConfig</td><td>The <a class="el" href="group__dspi__master__driver.html#structdspi__dma__master__user__config__t" title="The user configuration structure for the DSPI master driver with DMA. ">dspi_dma_master_user_config_t</a> user configuration structure. The user populates the members of this structure and passes the pointer of the structure into the function. </td></tr>
    <tr><td class="paramname">stcdSrc2CmdDataLast</td><td>This is a pointer to a structure of the stcdSrc2CmdDataLast type. It needs to be aligned to a 32-byte boundary. Some compilers allow you to use a #pragma directive to align a variable to a desired boundary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kStatus_DSPI_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga92cfdcd50aa81b04c683394ba61da358"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_DmaMasterDeinit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function resets the DSPI peripheral, gates its clock, disables any used interrupts to the core, and releases any used DMA channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_DSPI_Success indicating successful de-initialization </dd></dl>

</div>
</div>
<a class="anchor" id="ga17310974f56a00f4d5ef03120c629051"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_DmaMasterSetDelay </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dspi__hal.html#ga1ca2fbee37b3cb046c075a7e765d64ed">dspi_delay_type_t</a>&#160;</td>
          <td class="paramname"><em>whichDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delayInNanoSec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>calculatedDelay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function uses the DSPI module delay options to "fine tune" some of the signal timings and match the timing needs of a slower peripheral device. This is an optional function that can be called after the DSPI module has been initialized for master mode. The bus timing delays that can be adjusted are listed below:</p>
<p>PCS to SCK Delay: Adjustable delay option between the assertion of the PCS signal to the first SCK edge.</p>
<p>After SCK Delay: Adjustable delay option between the last edge of SCK to the de-assertion of the PCS signal.</p>
<p>Delay after Transfer: Adjustable delay option between the de-assertion of the PCS signal for a frame to the assertion of the PCS signal for the next frame. Note that this is not adjustable for continuous clock mode because this delay is fixed at one SCK period.</p>
<p>Each of the above delay parameters use both a pre-scalar and scalar value to calculate the needed delay. This function takes in as a parameter the desired delay type and the delay value (in nanoseconds), calculates the values needed for the prescaler and scaler. Returning the actual calculated delay as an exact delay match may not be possible. In this case, the closest match is calculated without going below the desired delay value input. It is possible to input a very large delay value that exceeds the capability of the part, in which case the maximum supported delay is returned. In addition, the function returns an out-of-range status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">whichDelay</td><td>The desired delay to configure, must be of type dspi_delay_type_t </td></tr>
    <tr><td class="paramname">delayInNanoSec</td><td>The desired delay value in nano-seconds. </td></tr>
    <tr><td class="paramname">calculatedDelay</td><td>The calculated delay that best matches the desired delay (in nano-seconds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either kStatus_DSPI_Success or kStatus_DSPI_OutOfRange if the desired delay exceeds the capability of the device. </dd></dl>

</div>
</div>
<a class="anchor" id="ga632e7cbfcd84625a482befcb78175c08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_DmaMasterConfigureBus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__dspi__master__driver.html#structdspi__dma__device__t">dspi_dma_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>calculatedBaudRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The term "device" is used to indicate the SPI device for which the DSPI master is communicating. The user has two options to configure the device parameters: pass in the pointer to the device configuration structure to the desired transfer function (see DSPI_DRV_DmaMasterTransferBlocking or DSPI_DRV_DmaMasterTransfer) or pass it in to the DSPI_DRV_DmaMasterConfigureBus function. The user can pass in a device structure to the transfer function which contains the parameters for the bus (the transfer function then calls this function). However, the user has the option to call this function directly especially to get the calculated baud rate, at which point they may pass in NULL for the device structure in the transfer function (assuming they have called this configure bus function first). This is an example to set up the <a class="el" href="group__dspi__master__driver.html#structdspi__device__t" title="Data structure containing information about a device on the SPI bus. ">dspi_device_t</a> structure to call the DSPI_DRV_DmaMasterConfigureBus function by passing in these parameters: </p>
<div class="fragment"><div class="line"><a class="code" href="group__dspi__master__driver.html#structdspi__dma__device__t">dspi_dma_device_t</a> spiDevice;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#a99d8d0dec68d5d2c1de35f8bb8b66a75">bitsPerFrame</a> = 16;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#ad751cbe15bfe01f02088e2a36059774a">clkPhase</a> = <a class="code" href="group__dspi__hal.html#gga4269ec144334dd60666a92e6fd2c1476ada723d5970a0b0a28d96a0e707cabd9c">kDspiClockPhase_FirstEdge</a>;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#a8926c27980536d08b063f984cc5dc751">clkPolarity</a> = <a class="code" href="group__dspi__hal.html#gga1e0a9074742794ef89f597d220296651afffdb6de18c3b46c509c406ac7230586">kDspiClockPolarity_ActiveHigh</a>;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#a7b5fc2246586c461ebd0325bba2e3113">direction</a> = <a class="code" href="group__dspi__hal.html#gga06fad8ae17b680f6dddfd798c9d3b30daed75ebb641f649ff0c4eb77d2624bcf2">kDspiMsbFirst</a>;</div>
<div class="line">spiDevice.<a class="code" href="group__dspi__master__driver.html#a8a1f0a877df8f0b1536f7ac287ce9a98">bitsPerSec</a> = 50000;</div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga632e7cbfcd84625a482befcb78175c08">DSPI_DRV_DmaMasterConfigureBus</a>(instance, &amp;spiDevice, &amp;calculatedBaudRate);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">device</td><td>Pointer to the device information structure. This structure contains the settings for the SPI bus configuration. The device parameters are the desired baud rate (in bits-per-sec), and the data format field which consists of bits-per-frame, clock polarity and phase, and data shift direction. </td></tr>
    <tr><td class="paramname">calculatedBaudRate</td><td>The calculated baud rate passed back to the user to determine if the calculated baud rate is close enough to meet the needs. The baud rate never exceeds the desired baud rate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kStatus_DSPI_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1bf6367527ef5acd3e918a5d9daf299f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_DmaMasterTransferBlocking </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__dspi__master__driver.html#structdspi__dma__device__t">dspi_dma_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>sendBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>receiveBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>transferByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function simultaneously sends and receives data on the SPI bus, because the SPI is naturally a full-duplex bus. The function does not return until the transfer is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">device</td><td>Pointer to the device information structure. This structure contains the settings for the SPI bus configuration in this transfer. You may pass NULL for this parameter, in which case the current bus configuration is used unmodified. The device can be configured separately by calling the DSPI_DRV_DmaMasterConfigureBus function. </td></tr>
    <tr><td class="paramname">sendBuffer</td><td>The pointer to the data buffer of the data to send. You may pass NULL for this parameter and bytes with a value of 0 (zero) is sent. </td></tr>
    <tr><td class="paramname">receiveBuffer</td><td>Pointer to the buffer where the received bytes are stored. If you pass NULL for this parameter, the received bytes are ignored. </td></tr>
    <tr><td class="paramname">transferByteCount</td><td>The number of bytes to send and receive. </td></tr>
    <tr><td class="paramname">timeout</td><td>A timeout for the transfer in milliseconds. If the transfer takes longer than this amount of time, the transfer is aborted and a kStatus_SPI_Timeout error returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_DSPI_Success The transfer was successful, or kStatus_DSPI_Busy Cannot perform transfer because a transfer is already in progress, or kStatus_DSPI_Timeout The transfer timed out and was aborted. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9bca76b948920da0ef56ed096fdd8c3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_DmaMasterTransfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__dspi__master__driver.html#structdspi__dma__device__t">dspi_dma_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>sendBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>receiveBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>transferByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns immediately. The user must check back whether the transfer is complete (using the DSPI_DRV_DmaMasterGetTransferStatus function). This function simultaneously sends and receives data on the SPI bus because the SPI is a full-duplex bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">device</td><td>Pointer to the device information structure. This structure contains the settings for the SPI bus configuration in this transfer. You may pass NULL for this parameter, in which case the current bus configuration is used unmodified. The device can be configured separately by calling the DSPI_DRV_DmaMasterConfigureBus function. </td></tr>
    <tr><td class="paramname">sendBuffer</td><td>The pointer to the data buffer of the data to send. You may pass NULL for this parameter, in which case bytes with a value of 0 (zero) are sent. </td></tr>
    <tr><td class="paramname">receiveBuffer</td><td>Pointer to the buffer where the received bytes are stored. If you pass NULL for this parameter, the received bytes are ignored. </td></tr>
    <tr><td class="paramname">transferByteCount</td><td>The number of bytes to send and receive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_DSPI_Success The transfer was successful, or kStatus_DSPI_Busy Cannot perform transfer because a transfer is already in progress. </dd></dl>

</div>
</div>
<a class="anchor" id="ga745e362e61507e5dc5d09212d131fa0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_DmaMasterGetTransferStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>framesTransferred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When performing an a-sync transfer, the user can call this function to ascertain the state of the current transfer: in progress (or busy) or complete (success). In addition, if the transfer is still in progress, the user can get the number of words that have been transferred up to now.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">framesTransferred</td><td>Pointer to value populated with the number of frames that have been sent during the active transfer. A frame is defined as the number of bits per frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_DSPI_Success The transfer has completed successfully, or kStatus_DSPI_Busy The transfer is still in progress. framesTransferred is filled with the number of words that have been transferred so far. </dd></dl>

</div>
</div>
<a class="anchor" id="gaea95c93e0cf21a725c327606f6f5ffba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_DmaMasterAbortTransfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>During an a-sync transfer, the user has the option to terminate the transfer early if the transfer is still in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_DSPI_Success The transfer was successful, or kStatus_DSPI_NoTransferInProgress No transfer is currently in progress. </dd></dl>

</div>
</div>
<a class="anchor" id="ga056aee779cd846ee43d4dc778f5ee6bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_EdmaMasterInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dspi__master__driver.html#structdspi__edma__master__state__t">dspi_edma_master_state_t</a> *&#160;</td>
          <td class="paramname"><em>dspiEdmaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__dspi__master__driver.html#structdspi__edma__master__user__config__t">dspi_edma_master_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>userConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *&#160;</td>
          <td class="paramname"><em>stcdSrc2CmdDataLast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function uses a DMA-driven method for transferring data. This function initializes the run-time state structure to track the ongoing transfers, ungates the clock to the DSPI module, resets the DSPI module, initializes the module to user-defined settings and default settings, configures the IRQ state structure, enables the module-level interrupt to the core, and enables the DSPI module. The CTAR parameter is special in that it allows the user to have different SPI devices connected to the same DSPI module instance in addition to different peripheral chip selects. Each CTAR contains the bus attributes associated with that particular SPI device. For most use cases, where only one SPI device is connected per DSPI module instance, use CTAR0. This is an example to set up and call the DSPI_DRV_EdmaMasterInit function by passing in these parameters: </p>
<div class="fragment"><div class="line"><a class="code" href="group__dspi__master__driver.html#structdspi__edma__master__state__t">dspi_edma_master_state_t</a> dspiEdmaState; &lt;- the user allocates memory <span class="keywordflow">for</span> <span class="keyword">this</span> structure</div>
<div class="line">uint32_t calculatedBaudRate;</div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#structdspi__edma__master__user__config__t">dspi_edma_master_user_config_t</a> userConfig; &lt;- the user populates members <span class="keywordflow">for</span> <span class="keyword">this</span> structure</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#a48fd49026678919882db3f457aef07da">isChipSelectContinuous</a> = <span class="keyword">false</span>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#af07a5d781ecdd79c5615264c24654726">isSckContinuous</a> = <span class="keyword">false</span>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#ad0e98667e6269f6138154852b1bc9a99">pcsPolarity</a> = <a class="code" href="group__dspi__hal.html#ggab466e73cb54b2c023459d43918c4197daf89a174f7da2c2d1dd94eaee5f451ac7">kDspiPcs_ActiveLow</a>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#a9a44b97547b785015cf8383d4c5a43c9">whichCtar</a> = <a class="code" href="group__dspi__hal.html#gga992d5562af4cf4c45371feb8c5c1a1bfa21d94da5d7c4e6134907fad358147b35">kDspiCtar0</a>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#abfd1f1c44dd7177a070d08e2884ef1d1">whichPcs</a> = <a class="code" href="group__dspi__hal.html#gga3d9d9a8fe16a51e6c697a547ab65bef1abf98b398d467bec5ce1332e7769b9c97">kDspiPcs0</a>;</div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga056aee779cd846ee43d4dc778f5ee6bc">DSPI_DRV_EdmaMasterInit</a>(masterInstance, &amp;dspiEdmaState, &amp;userConfig);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">dspiEdmaState</td><td>The pointer to the DSPI EDMA master driver state structure. The user passes the memory for the run-time state structure. The DSPI master driver populates the members. The run-time state structure keeps track of the transfer in progress. </td></tr>
    <tr><td class="paramname">userConfig</td><td>The <a class="el" href="group__dspi__master__driver.html#structdspi__edma__master__user__config__t" title="The user configuration structure for the DSPI master driver with EDMA. ">dspi_edma_master_user_config_t</a> user configuration structure. The user populates the members of this structure and passes the pointer of the structure into the function. </td></tr>
    <tr><td class="paramname">stcdSrc2CmdDataLast</td><td>This is a pointer to a structure of the stcdSrc2CmdDataLast type. It needs to be aligned to a 32-byte boundary. Some compilers allow you to use a #pragma directive to align a variable to a desired boundary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kStatus_DSPI_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ec2de01872d7f75a27bb68c34edc710"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_EdmaMasterDeinit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function resets the DSPI peripheral, gates its clock, disables any used interrupts to the core, and releases any used DMA channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_DSPI_Success indicating successful de-initialization </dd></dl>

</div>
</div>
<a class="anchor" id="ga952853adf4ad08153e70b0f78cf2d926"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_EdmaMasterSetDelay </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dspi__hal.html#ga1ca2fbee37b3cb046c075a7e765d64ed">dspi_delay_type_t</a>&#160;</td>
          <td class="paramname"><em>whichDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delayInNanoSec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>calculatedDelay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function uses the DSPI module delay options to "fine tune" some of the signal timings and match the timing needs of a slower peripheral device. This is an optional function that can be called after the DSPI module has been initialized for master mode. The bus timing delays that can be adjusted are listed below:</p>
<p>PCS to SCK Delay: Adjustable delay option between the assertion of the PCS signal to the first SCK edge.</p>
<p>After SCK Delay: Adjustable delay option between the last edge of SCK to the de-assertion of the PCS signal.</p>
<p>Delay after Transfer: Adjustable delay option between the de-assertion of the PCS signal for a frame to the assertion of the PCS signal for the next frame. Note that this is not adjustable for continuous clock mode because this delay is fixed at one SCK period.</p>
<p>Each of the above delay parameters uses both a pre-scalar and scalar value to calculate the needed delay. This function takes the desired delay type as a parameter and the delay value (in nanoseconds), calculates the values needed for the prescaler and scaler. Returning the actual calculated delay as an exact delay match may not be possible. In this situation, the closest match is calculated without going below the desired delay value input. It is possible to input a very large delay value that exceeds the capability of the part, in which case the maximum supported delay is returned. In addition, the function returns an out-of-range status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">whichDelay</td><td>The desired delay to configure, must be of type dspi_delay_type_t </td></tr>
    <tr><td class="paramname">delayInNanoSec</td><td>The desired delay value in nanoseconds. </td></tr>
    <tr><td class="paramname">calculatedDelay</td><td>The calculated delay that best matches the desired delay (in nanoseconds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either kStatus_DSPI_Success or kStatus_DSPI_OutOfRange if the desired delay exceeds the capability of the device. </dd></dl>

</div>
</div>
<a class="anchor" id="ga87b4ad456a0f360cb1bb22d9c0fd3dcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_EdmaMasterConfigureBus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__dspi__master__driver.html#structdspi__edma__device__t">dspi_edma_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>calculatedBaudRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The term "device" describes the SPI device for which the DSPI master is communicating. The user has two options to configure the device parameters: pass in the pointer to the device configuration structure to the desired transfer function (see DSPI_DRV_EdmaMasterTransferBlocking or DSPI_DRV_EdmaMasterTransfer) or pass it in to the DSPI_DRV_EdmaMasterConfigureBus function. The user can pass in a device structure to the transfer function which contains the parameters for the bus (the transfer function then calls this function). However, the user has the option to call this function directly to get the calculated baud rate, at which point, the user may pass in NULL for the device structure in the transfer function (assuming they have called this configure bus function first). This is an example to set up the <a class="el" href="group__dspi__master__driver.html#structdspi__device__t" title="Data structure containing information about a device on the SPI bus. ">dspi_device_t</a> structure to call the DSPI_DRV_EdmaMasterConfigureBus function by passing in these parameters: </p>
<div class="fragment"><div class="line"><a class="code" href="group__dspi__master__driver.html#structdspi__edma__device__t">dspi_edma_device_t</a> spiDevice;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#a99d8d0dec68d5d2c1de35f8bb8b66a75">bitsPerFrame</a> = 16;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#ad751cbe15bfe01f02088e2a36059774a">clkPhase</a> = <a class="code" href="group__dspi__hal.html#gga4269ec144334dd60666a92e6fd2c1476ada723d5970a0b0a28d96a0e707cabd9c">kDspiClockPhase_FirstEdge</a>;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#a8926c27980536d08b063f984cc5dc751">clkPolarity</a> = <a class="code" href="group__dspi__hal.html#gga1e0a9074742794ef89f597d220296651afffdb6de18c3b46c509c406ac7230586">kDspiClockPolarity_ActiveHigh</a>;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#a7b5fc2246586c461ebd0325bba2e3113">direction</a> = <a class="code" href="group__dspi__hal.html#gga06fad8ae17b680f6dddfd798c9d3b30daed75ebb641f649ff0c4eb77d2624bcf2">kDspiMsbFirst</a>;</div>
<div class="line">spiDevice.<a class="code" href="group__dspi__master__driver.html#a11c692151d0c51699d2818c4dc9ff29a">bitsPerSec</a> = 50000;</div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga87b4ad456a0f360cb1bb22d9c0fd3dcb">DSPI_DRV_EdmaMasterConfigureBus</a>(instance, &amp;spiDevice, &amp;calculatedBaudRate);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">device</td><td>Pointer to the device information structure. This structure contains the settings for the SPI bus configuration. The device parameters are the desired baud rate (in bits-per-sec), and the data format field which consists of bits-per-frame, clock polarity and phase, and data shift direction. </td></tr>
    <tr><td class="paramname">calculatedBaudRate</td><td>The calculated baud rate passed back to the user to determine if the calculated baud rate is close enough to meet the needs. The baud rate never exceeds the desired baud rate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kStatus_DSPI_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga494b8d6379bd3879cfc7f59f7129bbf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_EdmaMasterTransferBlocking </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__dspi__master__driver.html#structdspi__edma__device__t">dspi_edma_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>sendBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>receiveBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>transferByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function simultaneously sends and receives data on the SPI bus, because the SPI is naturally a full-duplex bus. The function does not return until the transfer is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">device</td><td>Pointer to the device information structure. This structure contains the settings for the SPI bus configuration in this transfer. You may pass NULL for this parameter, in which case the current bus configuration is used unmodified. The device can be configured separately by calling the DSPI_DRV_EdmaMasterConfigureBus function. </td></tr>
    <tr><td class="paramname">sendBuffer</td><td>The pointer to the data buffer of the data to send. You may pass NULL for this parameter and bytes with a value of 0 (zero) is sent. </td></tr>
    <tr><td class="paramname">receiveBuffer</td><td>Pointer to the buffer where the received bytes are stored. If you pass NULL for this parameter, the received bytes are ignored. </td></tr>
    <tr><td class="paramname">transferByteCount</td><td>The number of bytes to send and receive. </td></tr>
    <tr><td class="paramname">timeout</td><td>A timeout for the transfer in milliseconds. If the transfer takes longer than this amount of time, the transfer is aborted and a kStatus_SPI_Timeout error returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_DSPI_Success The transfer was successful, or kStatus_DSPI_Busy Cannot perform transfer because a transfer is already in progress, or kStatus_DSPI_Timeout The transfer timed out and was aborted. </dd></dl>

</div>
</div>
<a class="anchor" id="ga72a411c2ed35d3ae70267601c4a8115e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_EdmaMasterTransfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__dspi__master__driver.html#structdspi__edma__device__t">dspi_edma_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>sendBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>receiveBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>transferByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns immediately. The user must check back whether the transfer is complete (using the DSPI_DRV_EdmaMasterGetTransferStatus function). This function simultaneously sends and receives data on the SPI bus because the SPI is a full-duplex bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">device</td><td>Pointer to the device information structure. This structure contains the settings for the SPI bus configuration in this transfer. You may pass NULL for this parameter, in which case the current bus configuration is used unmodified. The device can be configured separately by calling the DSPI_DRV_EdmaMasterConfigureBus function. </td></tr>
    <tr><td class="paramname">sendBuffer</td><td>The pointer to the data buffer of the data to send. You may pass NULL for this parameter, in which case bytes with a value of 0 (zero) are sent. </td></tr>
    <tr><td class="paramname">receiveBuffer</td><td>Pointer to the buffer where the received bytes are stored. If you pass NULL for this parameter, the received bytes are ignored. </td></tr>
    <tr><td class="paramname">transferByteCount</td><td>The number of bytes to send and receive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_DSPI_Success The transfer was successful, or kStatus_DSPI_Busy Cannot perform transfer because a transfer is already in progress. </dd></dl>

</div>
</div>
<a class="anchor" id="ga45330690d03a2c0c249d94322141d297"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_EdmaMasterGetTransferStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>framesTransferred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When performing an a-sync transfer, the user can call this function to ascertain the state of the current transfer: in progress (or busy) or complete (success). In addition, if the transfer is still in progress, the user can get the number of words that have been transferred up to now.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">framesTransferred</td><td>Pointer to value populated with the number of frames that have been sent during the active transfer. A frame is defined as the number of bits per frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_DSPI_Success The transfer has completed successfully, or kStatus_DSPI_Busy The transfer is still in progress. framesTransferred is filled with the number of words that have been transferred so far. </dd></dl>

</div>
</div>
<a class="anchor" id="gae8710c8a2abd897a2ccd4a3461fa3dd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_EdmaMasterAbortTransfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>During an a-sync transfer, the user has the option to terminate the transfer early if the transfer is still in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_DSPI_Success The transfer was successful, or kStatus_DSPI_NoTransferInProgress No transfer is currently in progress. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4fb0849778fe0d019745c3e717070fe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DSPI_DRV_EdmaMasterIRQHandler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This handler uses the buffers stored in the <a class="el" href="group__dspi__master__driver.html#structdspi__master__state__t" title="Runtime state structure for the DSPI master driver. ">dspi_master_state_t</a> structures to transfer data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga37d57c2ed98daaa6340d50054d617967"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_MasterInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dspi__master__driver.html#structdspi__master__state__t">dspi_master_state_t</a> *&#160;</td>
          <td class="paramname"><em>dspiState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__dspi__master__driver.html#structdspi__master__user__config__t">dspi_master_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>userConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function uses a CPU interrupt driven method for transferring data. This function initializes the run-time state structure to track the ongoing transfers, un-gates the clock to the DSPI module, resets the DSPI module, initializes the module to user defined settings and default settings, configures the IRQ state structure, enables the module-level interrupt to the core, and enables the DSPI module. The CTAR parameter is special in that it allows the user to have different SPI devices connected to the same DSPI module instance in addition to different peripheral device selects. Each CTAR contains the bus attributes associated with that particular SPI device. For most use cases where only one SPI device is connected per DSPI module instance, use CTAR0. This is an example to set up the <a class="el" href="group__dspi__master__driver.html#structdspi__master__state__t" title="Runtime state structure for the DSPI master driver. ">dspi_master_state_t</a> and the <a class="el" href="group__dspi__master__driver.html#structdspi__master__user__config__t" title="The user configuration structure for the DSPI master driver. ">dspi_master_user_config_t</a> parameters and to call the DSPI_DRV_MasterInit function by passing in these parameters: </p>
<div class="fragment"><div class="line"><a class="code" href="group__dspi__master__driver.html#structdspi__master__state__t">dspi_master_state_t</a> dspiMasterState; &lt;- the user  allocates memory <span class="keywordflow">for</span> <span class="keyword">this</span> structure</div>
<div class="line">uint32_t calculatedBaudRate;</div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#structdspi__master__user__config__t">dspi_master_user_config_t</a> userConfig; &lt;- the user populates members <span class="keywordflow">for</span> <span class="keyword">this</span> structure</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#ada9c810904ee8e24abefb25b9045c125">isChipSelectContinuous</a> = <span class="keyword">false</span>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#a6c46d04d4031ebb56a12c665a0d17aaa">isSckContinuous</a> = <span class="keyword">false</span>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#aa8b1f2458668337b90a340a4ecaf4aa4">pcsPolarity</a> = <a class="code" href="group__dspi__hal.html#ggab466e73cb54b2c023459d43918c4197daf89a174f7da2c2d1dd94eaee5f451ac7">kDspiPcs_ActiveLow</a>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#a8514df82b4b4c68f4de58a3ed160faf1">whichCtar</a> = <a class="code" href="group__dspi__hal.html#gga992d5562af4cf4c45371feb8c5c1a1bfa21d94da5d7c4e6134907fad358147b35">kDspiCtar0</a>;</div>
<div class="line">userConfig.<a class="code" href="group__dspi__master__driver.html#a6433c1800d2a85da45ae347022c3cd9b">whichPcs</a> = <a class="code" href="group__dspi__hal.html#gga3d9d9a8fe16a51e6c697a547ab65bef1abf98b398d467bec5ce1332e7769b9c97">kDspiPcs0</a>;</div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga37d57c2ed98daaa6340d50054d617967">DSPI_DRV_MasterInit</a>(masterInstance, &amp;dspiMasterState, &amp;userConfig);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">dspiState</td><td>The pointer to the DSPI master driver state structure. The user passes the memory for this run-time state structure. The DSPI master driver populates the members. This run-time state structure keeps track of the transfer in progress. </td></tr>
    <tr><td class="paramname">userConfig</td><td>The <a class="el" href="group__dspi__master__driver.html#structdspi__master__user__config__t" title="The user configuration structure for the DSPI master driver. ">dspi_master_user_config_t</a> user configuration structure. The user populates the members of this structure and passes the pointer of this structure to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kStatus_DSPI_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf173a42da34da0bfa391f629b8bbfd44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_MasterDeinit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function resets the DSPI peripheral, gates its clock, and disables the interrupt to the core.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_DSPI_Success indicating successful de-initialization </dd></dl>

</div>
</div>
<a class="anchor" id="ga705cfda5272cff31714e7167eed5ca7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_MasterSetDelay </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dspi__hal.html#ga1ca2fbee37b3cb046c075a7e765d64ed">dspi_delay_type_t</a>&#160;</td>
          <td class="paramname"><em>whichDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delayInNanoSec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>calculatedDelay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function involves the DSPI module's delay options to "fine tune" some of the signal timings and match the timing needs of a slower peripheral device. This is an optional function that can be called after the DSPI module has been initialized for master mode. The bus timing delays that can be adjusted are listed below:</p>
<p>PCS to SCK Delay: Adjustable delay option between the assertion of the PCS signal to the first SCK edge.</p>
<p>After SCK Delay: Adjustable delay option between the last edge of SCK to the de-assertion of the PCS signal.</p>
<p>Delay after Transfer: Adjustable delay option between the de-assertion of the PCS signal for a frame to the assertion of the PCS signal for the next frame. Note that this is not adjustable for continuous clock mode because this delay is fixed at one SCK period.</p>
<p>Each of the above delay parameters use both a pre-scalar and scalar value to calculate the needed delay. This function takes in as a parameter the desired delay type and the delay value (in nanoseconds), calculates the values needed for the prescaler and scaler. Returning the actual calculated delay as an exact delay match may not be possible. In this case, the closest match is calculated without going below the desired delay value input. It is possible to input a very large delay value that exceeds the capability of the part, in which case the maximum supported delay is returned. In addition, the function returns an out-of-range status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">whichDelay</td><td>The desired delay to configure, must be of type dspi_delay_type_t </td></tr>
    <tr><td class="paramname">delayInNanoSec</td><td>The desired delay value in nanoseconds. </td></tr>
    <tr><td class="paramname">calculatedDelay</td><td>The calculated delay that best matches the desired delay (in nanoseconds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either kStatus_DSPI_Success or kStatus_DSPI_OutOfRange if the desired delay exceeds the capability of the device. </dd></dl>

</div>
</div>
<a class="anchor" id="ga484ec4f6557a5f8aa3dffa4dfc7b3ba0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_MasterConfigureBus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__dspi__master__driver.html#structdspi__device__t">dspi_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>calculatedBaudRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The term "device" is used to indicate the SPI device for which the DSPI master is communicating. The user has two options to configure the device parameters: either pass in the pointer to the device configuration structure to the desired transfer function (see DSPI_DRV_MasterTransferBlocking or DSPI_DRV_MasterTransfer) or pass it in to the DSPI_DRV_MasterConfigureBus function. The user can pass in a device structure to the transfer function which contains the parameters for the bus (the transfer function then calls this function). However, the user has the option to call this function directly especially to get the calculated baud rate, at which point they may pass in NULL for the device structure in the transfer function (assuming they have called this configure bus function first). This is an example to set up the <a class="el" href="group__dspi__master__driver.html#structdspi__device__t" title="Data structure containing information about a device on the SPI bus. ">dspi_device_t</a> structure to call the DSPI_DRV_MasterConfigureBus function by passing in these parameters: </p>
<div class="fragment"><div class="line"><a class="code" href="group__dspi__master__driver.html#structdspi__device__t">dspi_device_t</a> spiDevice;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#a99d8d0dec68d5d2c1de35f8bb8b66a75">bitsPerFrame</a> = 16;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#ad751cbe15bfe01f02088e2a36059774a">clkPhase</a> = <a class="code" href="group__dspi__hal.html#gga4269ec144334dd60666a92e6fd2c1476ada723d5970a0b0a28d96a0e707cabd9c">kDspiClockPhase_FirstEdge</a>;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#a8926c27980536d08b063f984cc5dc751">clkPolarity</a> = <a class="code" href="group__dspi__hal.html#gga1e0a9074742794ef89f597d220296651afffdb6de18c3b46c509c406ac7230586">kDspiClockPolarity_ActiveHigh</a>;</div>
<div class="line">spiDevice.dataBusConfig.<a class="code" href="group__dspi__hal.html#a7b5fc2246586c461ebd0325bba2e3113">direction</a> = <a class="code" href="group__dspi__hal.html#gga06fad8ae17b680f6dddfd798c9d3b30daed75ebb641f649ff0c4eb77d2624bcf2">kDspiMsbFirst</a>;</div>
<div class="line">spiDevice.<a class="code" href="group__dspi__master__driver.html#ac497d381e4bb407f8968ad34c47e7abd">bitsPerSec</a> = 50000;</div>
<div class="line"><a class="code" href="group__dspi__master__driver.html#ga484ec4f6557a5f8aa3dffa4dfc7b3ba0">DSPI_DRV_MasterConfigureBus</a>(instance, &amp;spiDevice, &amp;calculatedBaudRate);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">device</td><td>Pointer to the device information structure. This structure contains the settings for the SPI bus configuration. The device parameters are the desired baud rate (in bits-per-sec), and the data format field which consists of bits-per-frame, clock polarity and phase, and data shift direction. </td></tr>
    <tr><td class="paramname">calculatedBaudRate</td><td>The calculated baud rate passed back to the user to determine if the calculated baud rate is close enough to meet the needs. The baud rate never exceeds the desired baud rate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kStatus_DSPI_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="gad4a5101fdb19f5b242f1ad06d9c93b4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_MasterTransferBlocking </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__dspi__master__driver.html#structdspi__device__t">dspi_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>sendBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>receiveBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>transferByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function simultaneously sends and receives data on the SPI bus, as SPI is naturally a full-duplex bus. The function does not return until the transfer is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">device</td><td>Pointer to the device information structure. This structure contains the settings for the SPI bus configuration in this transfer. You may pass NULL for this parameter, in which case the current bus configuration is used unmodified. The device can be configured separately by calling the DSPI_DRV_MasterConfigureBus function. </td></tr>
    <tr><td class="paramname">sendBuffer</td><td>The pointer to the data buffer of the data to send. You may pass NULL for this parameter and bytes with a value of 0 (zero) is sent. </td></tr>
    <tr><td class="paramname">receiveBuffer</td><td>Pointer to the buffer where the received bytes are stored. If you pass NULL for this parameter, the received bytes are ignored. </td></tr>
    <tr><td class="paramname">transferByteCount</td><td>The number of bytes to send and receive. </td></tr>
    <tr><td class="paramname">timeout</td><td>A timeout for the transfer in milliseconds. If the transfer takes longer than this amount of time, the transfer is aborted and a <a class="el" href="group__spi__hal.html#gga856ecadf3d7fe18c4fc3ae56500f8982a496ced6fffc33d7bbeb01d203dfc4836" title="SPI transfer timed out. ">kStatus_SPI_Timeout</a> error returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_DSPI_Success The transfer was successful, or kStatus_DSPI_Busy Cannot perform transfer because a transfer is already in progress, or kStatus_DSPI_Timeout The transfer timed out and was aborted. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d475636c45ae6f0f2bced51deb37487"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_MasterTransfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__dspi__master__driver.html#structdspi__device__t">dspi_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>sendBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>receiveBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>transferByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns immediately. The user needs to check whether the transfer is complete using the DSPI_DRV_MasterGetTransferStatus function. This function simultaneously sends and receives data on the SPI bus because the SPI is naturally a full-duplex bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">device</td><td>Pointer to the device information structure. This structure contains the settings for the SPI bus configuration in this transfer. You may pass NULL for this parameter, in which case the current bus configuration is used unmodified. The device can be configured separately by calling the DSPI_DRV_MasterConfigureBus function. </td></tr>
    <tr><td class="paramname">sendBuffer</td><td>The pointer to the data buffer of the data to send. You may pass NULL for this parameter, in which case bytes with a value of 0 (zero) are sent. </td></tr>
    <tr><td class="paramname">receiveBuffer</td><td>Pointer to the buffer where the received bytes are stored. If you pass NULL for this parameter, the received bytes are ignored. </td></tr>
    <tr><td class="paramname">transferByteCount</td><td>The number of bytes to send and receive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_DSPI_Success The transfer was successful, or kStatus_DSPI_Busy Cannot perform transfer because a transfer is already in progress. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4c962f4f1d462d30d275c52f118d04c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_MasterGetTransferStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>framesTransferred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When performing an a-sync transfer, the user can call this function to ascertain the state of the current transfer: in progress (or busy) or complete (success). In addition, if the transfer is still in progress, the user can get the number of words that have been transferred up to now.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
    <tr><td class="paramname">framesTransferred</td><td>Pointer to value that is filled in with the number of frames that have been sent in the active transfer. A frame is defined as the number of bits per frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_DSPI_Success The transfer has completed successfully, or kStatus_DSPI_Busy The transfer is still in progress. framesTransferred is filled with the number of words that have been transferred so far. </dd></dl>

</div>
</div>
<a class="anchor" id="ga08ca2ffc48f8a7fe72694571e067b5a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dspi__hal.html#ga34b3b8e88f67e380c7e5f50e2422774c">dspi_status_t</a> DSPI_DRV_MasterAbortTransfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>During an a-sync transfer, the user has the option to terminate the transfer early if the transfer is still in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kStatus_DSPI_Success The transfer was successful, or kStatus_DSPI_NoTransferInProgress No transfer is currently in progress. </dd></dl>

</div>
</div>
<a class="anchor" id="gacf2594a27099e24b50c209d401910efe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DSPI_DRV_MasterIRQHandler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This handler uses the buffers stored in the <a class="el" href="group__dspi__master__driver.html#structdspi__master__state__t" title="Runtime state structure for the DSPI master driver. ">dspi_master_state_t</a> structs to transfer data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance number of the DSPI peripheral. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga19a374f8af816ac684016ad76f4c5475"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_Type* const g_dspiBase[SPI_INSTANCE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gac730f6d2d81a79859583832ea33d61c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IRQn_Type g_dspiIrqId[SPI_INSTANCE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga19a374f8af816ac684016ad76f4c5475"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_Type* const g_dspiBase[SPI_INSTANCE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gac730f6d2d81a79859583832ea33d61c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IRQn_Type g_dspiIrqId[SPI_INSTANCE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga19a374f8af816ac684016ad76f4c5475"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_Type* const g_dspiBase[SPI_INSTANCE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gac730f6d2d81a79859583832ea33d61c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IRQn_Type g_dspiIrqId[SPI_INSTANCE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer">Thu Sep 24 2015 &copy; 2015 Freescale Semiconductor, Inc. All rights reserved.
    </li>
  </ul>
</div>
</body>
</html>
