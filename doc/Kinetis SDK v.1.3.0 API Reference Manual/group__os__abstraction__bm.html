<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Kinetis SDK v.1.3 API Reference Manual: Bare Metal Abstraction Layer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fs_logo.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Kinetis SDK v.1.3 API Reference Manual
   &#160;<span id="projectnumber">Rev. 0</span>
   </div>
   <div id="projectbrief">Freescale Semiconductor, Inc.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__os__abstraction__bm.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Bare Metal Abstraction Layer<div class="ingroups"><a class="el" href="group__os__abstraction.html">OS Abstraction Layer (OSA)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The Kinetis SDK provides the Bare Metal Abstraction Layer for synchronization, mutual exclusion, message queue, etc.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structsemaphore__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#structsemaphore__t">semaphore_t</a></td></tr>
<tr class="memdesc:structsemaphore__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for an semaphore.  <a href="group__os__abstraction__bm.html#structsemaphore__t">More...</a><br/></td></tr>
<tr class="separator:structsemaphore__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structmutex__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#structmutex__t">mutex_t</a></td></tr>
<tr class="memdesc:structmutex__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for a mutex.  <a href="group__os__abstraction__bm.html#structmutex__t">More...</a><br/></td></tr>
<tr class="separator:structmutex__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structevent__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#structevent__t">event_t</a></td></tr>
<tr class="memdesc:structevent__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for an event object.  <a href="group__os__abstraction__bm.html#structevent__t">More...</a><br/></td></tr>
<tr class="separator:structevent__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtask__control__block__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#structtask__control__block__t">task_control_block_t</a></td></tr>
<tr class="memdesc:structtask__control__block__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task control block for bare metal.  <a href="group__os__abstraction__bm.html#structtask__control__block__t">More...</a><br/></td></tr>
<tr class="separator:structtask__control__block__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structmsg__queue__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#structmsg__queue__t">msg_queue_t</a></td></tr>
<tr class="memdesc:structmsg__queue__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for a message queue.  <a href="group__os__abstraction__bm.html#structmsg__queue__t">More...</a><br/></td></tr>
<tr class="separator:structmsg__queue__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga5ffcf301e911e4911ebb33f6d120b79b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ga5ffcf301e911e4911ebb33f6d120b79b">FSL_OSA_BM_TIMER_NONE</a>&#160;&#160;&#160;0U</td></tr>
<tr class="memdesc:ga5ffcf301e911e4911ebb33f6d120b79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bare Metal does not use timer.  <a href="#ga5ffcf301e911e4911ebb33f6d120b79b">More...</a><br/></td></tr>
<tr class="separator:ga5ffcf301e911e4911ebb33f6d120b79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd1345edb8713252108dffd4f7d961ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#gadd1345edb8713252108dffd4f7d961ab">FSL_OSA_BM_TIMER_LPTMER</a>&#160;&#160;&#160;1U</td></tr>
<tr class="memdesc:gadd1345edb8713252108dffd4f7d961ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bare Metal uses LPTMR as timer.  <a href="#gadd1345edb8713252108dffd4f7d961ab">More...</a><br/></td></tr>
<tr class="separator:gadd1345edb8713252108dffd4f7d961ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad95549b5ccdee2644886381c47507d1d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#gad95549b5ccdee2644886381c47507d1d">FSL_OSA_BM_TIMER_CONFIG</a>&#160;&#160;&#160;<a class="el" href="group__os__abstraction__bm.html#gadd1345edb8713252108dffd4f7d961ab">FSL_OSA_BM_TIMER_LPTMER</a></td></tr>
<tr class="memdesc:gad95549b5ccdee2644886381c47507d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure what timer is used in Bare Metal.  <a href="#gad95549b5ccdee2644886381c47507d1d">More...</a><br/></td></tr>
<tr class="separator:gad95549b5ccdee2644886381c47507d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c4bbd97efaa670e198fad62038ba771"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ga5c4bbd97efaa670e198fad62038ba771">OSA_WAIT_FOREVER</a>&#160;&#160;&#160;0xFFFFFFFFU</td></tr>
<tr class="memdesc:ga5c4bbd97efaa670e198fad62038ba771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant to pass as timeout value in order to wait indefinitely.  <a href="#ga5c4bbd97efaa670e198fad62038ba771">More...</a><br/></td></tr>
<tr class="separator:ga5c4bbd97efaa670e198fad62038ba771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a0fb3f79cc6bab55d41a1f2e1789da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ga11a0fb3f79cc6bab55d41a1f2e1789da">TASK_MAX_NUM</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:ga11a0fb3f79cc6bab55d41a1f2e1789da"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many tasks can the bare metal support.  <a href="#ga11a0fb3f79cc6bab55d41a1f2e1789da">More...</a><br/></td></tr>
<tr class="separator:ga11a0fb3f79cc6bab55d41a1f2e1789da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8cb2e5f9f9863520c4c9e4c3c47e3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ga0b8cb2e5f9f9863520c4c9e4c3c47e3f">FSL_OSA_TIME_RANGE</a>&#160;&#160;&#160;0xFFFFU</td></tr>
<tr class="memdesc:ga0b8cb2e5f9f9863520c4c9e4c3c47e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">OSA's time range in millisecond, OSA time wraps if exceeds this value.  <a href="#ga0b8cb2e5f9f9863520c4c9e4c3c47e3f">More...</a><br/></td></tr>
<tr class="separator:ga0b8cb2e5f9f9863520c4c9e4c3c47e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50f035ff4993767f49ca67b3847bfec4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ga50f035ff4993767f49ca67b3847bfec4">OSA_DEFAULT_INT_HANDLER</a>&#160;&#160;&#160;((<a class="el" href="group__os__abstraction.html#ga319b0b915c46a8b1adf9ef2c1ec3e7e1">osa_int_handler_t</a>)(&amp;<a class="el" href="group__os__abstraction__bm.html#ga4fcbeb17b7f10e57e297bf6b12a07e7e">DefaultISR</a>))</td></tr>
<tr class="memdesc:ga50f035ff4993767f49ca67b3847bfec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default interrupt handler installed in vector table.  <a href="#ga50f035ff4993767f49ca67b3847bfec4">More...</a><br/></td></tr>
<tr class="separator:ga50f035ff4993767f49ca67b3847bfec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga79a78f74479544e6d60e4ecaedf83752"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga79a78f74479544e6d60e4ecaedf83752"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ga79a78f74479544e6d60e4ecaedf83752">event_flags_t</a></td></tr>
<tr class="memdesc:ga79a78f74479544e6d60e4ecaedf83752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for an event flags group, bit 32 is reserved. <br/></td></tr>
<tr class="separator:ga79a78f74479544e6d60e4ecaedf83752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90774a4d1708f3e210d94c829b44eb86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga90774a4d1708f3e210d94c829b44eb86"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ga90774a4d1708f3e210d94c829b44eb86">task_param_t</a></td></tr>
<tr class="memdesc:ga90774a4d1708f3e210d94c829b44eb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for task parameter. <br/></td></tr>
<tr class="separator:ga90774a4d1708f3e210d94c829b44eb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad138ff72ead35c2ed90c90302fb0da1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad138ff72ead35c2ed90c90302fb0da1e"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#gad138ff72ead35c2ed90c90302fb0da1e">task_t</a> )(<a class="el" href="group__os__abstraction__bm.html#ga90774a4d1708f3e210d94c829b44eb86">task_param_t</a> param)</td></tr>
<tr class="memdesc:gad138ff72ead35c2ed90c90302fb0da1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for a task pointer. <br/></td></tr>
<tr class="separator:gad138ff72ead35c2ed90c90302fb0da1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d867ba7d27cb355a1827c2c11889bcc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2d867ba7d27cb355a1827c2c11889bcc"></a>
typedef <a class="el" href="group__os__abstraction__bm.html#structtask__control__block__t">task_control_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ga2d867ba7d27cb355a1827c2c11889bcc">task_handler_t</a></td></tr>
<tr class="memdesc:ga2d867ba7d27cb355a1827c2c11889bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for a task handler, returned by the OSA_TaskCreate function. <br/></td></tr>
<tr class="separator:ga2d867ba7d27cb355a1827c2c11889bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga184cb36aad264b6917c489bbc2b793a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga184cb36aad264b6917c489bbc2b793a5"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ga184cb36aad264b6917c489bbc2b793a5">task_stack_t</a></td></tr>
<tr class="memdesc:ga184cb36aad264b6917c489bbc2b793a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for a task stack. <br/></td></tr>
<tr class="separator:ga184cb36aad264b6917c489bbc2b793a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ee0d756e55f89abf869dcab383535c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga04ee0d756e55f89abf869dcab383535c"></a>
typedef <a class="el" href="group__os__abstraction__bm.html#structmsg__queue__t">msg_queue_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ga04ee0d756e55f89abf869dcab383535c">msg_queue_handler_t</a></td></tr>
<tr class="memdesc:ga04ee0d756e55f89abf869dcab383535c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for a message queue handler. <br/></td></tr>
<tr class="separator:ga04ee0d756e55f89abf869dcab383535c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4fcbeb17b7f10e57e297bf6b12a07e7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ga4fcbeb17b7f10e57e297bf6b12a07e7e">DefaultISR</a> (void)</td></tr>
<tr class="memdesc:ga4fcbeb17b7f10e57e297bf6b12a07e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default interrupt handler installed in vector table.  <a href="#ga4fcbeb17b7f10e57e297bf6b12a07e7e">More...</a><br/></td></tr>
<tr class="separator:ga4fcbeb17b7f10e57e297bf6b12a07e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Thread management</h2></td></tr>
<tr class="memitem:ga5b58984db92662727d4c6e612029ebb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ga5b58984db92662727d4c6e612029ebb4">OSA_PollAllOtherTasks</a> (void)</td></tr>
<tr class="memdesc:ga5b58984db92662727d4c6e612029ebb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls all task functions one time except for the current task.  <a href="#ga5b58984db92662727d4c6e612029ebb4">More...</a><br/></td></tr>
<tr class="separator:ga5b58984db92662727d4c6e612029ebb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37ea523ee533242cf8b8c3706a93d818"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ga37ea523ee533242cf8b8c3706a93d818">OSA_TASK_DEFINE</a>(task, stackSize)</td></tr>
<tr class="memdesc:ga37ea523ee533242cf8b8c3706a93d818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a task.  <a href="#ga37ea523ee533242cf8b8c3706a93d818">More...</a><br/></td></tr>
<tr class="separator:ga37ea523ee533242cf8b8c3706a93d818"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Message queues</h2></td></tr>
<tr class="memitem:gad27d9381348700acda99a4eedad3a0d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#gad27d9381348700acda99a4eedad3a0d7">MSG_QUEUE_DECLARE</a>(name, number, size)</td></tr>
<tr class="memdesc:gad27d9381348700acda99a4eedad3a0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro statically reserves the memory required for the queue.  <a href="#gad27d9381348700acda99a4eedad3a0d7">More...</a><br/></td></tr>
<tr class="separator:gad27d9381348700acda99a4eedad3a0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>


<h3><a class="anchor" id="osa_bm"></a>Bare Metal Abstraction Layer</h3><div class="textblock"><h1>Overview</h1>
When RTOSes are not used, bare metal abstraction layer provides semaphore, mutex, event, message queue, and so on. Because bare metal does not have a task scheduler, it is necessary to exercise caution while using bare metal abstraction layer.<h1>Bare Metal Task Management</h1>
By contrast to RTOSes, bare metal abstraction layer uses a poll mechanism to simulate a task. All task functions are linked into a list and called one-by-one. Therefore, bare metal task function should not contains an infinite loop. It must return at a proper time to let the other tasks run.Bare metal task does not support priority, all tasks use the same priority. The macro TASK_MAX_NUM defines how many tasks applications could create. If it is set to 0, then applications could not use task APIs.<h1>Bare Metal's Wait Functions</h1>
Bare metal wait functions, such as OSA_SemaWait and OSA_EventWait, return the kStatus_OSA_Idle if wait condition is not met and timeout has not occurred. Applications should catch this value and take proper actions. If the wait condition is set by the ISR, applications could wait in a loop:<div class="fragment"><div class="line"><span class="keywordtype">void</span> post_ISR(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">    <a class="code" href="group__os__abstraction.html#gaa5034a9787f489d989f22a06e509a192">OSA_SemaPost</a>(&amp;my_sem);</div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> wait_task(<a class="code" href="group__os__abstraction__bm.html#ga90774a4d1708f3e210d94c829b44eb86">task_param_t</a> param)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">    <span class="keywordflow">do</span></div>
<div class="line">    {</div>
<div class="line">        status = <a class="code" href="group__os__abstraction.html#ga653fc3e87d91a841348be7b0a0166422">OSA_SemaWait</a>(&amp;my_sem, 10);</div>
<div class="line">    } <span class="keywordflow">while</span>(<a class="code" href="group__os__abstraction.html#ggac620802974e82799bde8d7eeadecaea2a5ff8ef02cb571d5d5f92a7e816719a3d">kStatus_OSA_Idle</a> ==  status);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">}</div>
</div><!-- fragment -->In this example, if my_sem is not posted by the post_ISR, but posted by a task post_task, then OSA_SemaWait in loop could never get my_sem within the timeout because the post_task does not have a chance to post my_sem. In this situation, applications could be implemented as follows:<div class="fragment"><div class="line"><span class="keywordtype">void</span> post_task(<a class="code" href="group__os__abstraction__bm.html#ga90774a4d1708f3e210d94c829b44eb86">task_param_t</a> param)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">    <a class="code" href="group__os__abstraction.html#gaa5034a9787f489d989f22a06e509a192">OSA_SemaPost</a>(&amp;my_sem);</div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> wait_task(<a class="code" href="group__os__abstraction__bm.html#ga90774a4d1708f3e210d94c829b44eb86">task_param_t</a> param)</div>
<div class="line">{</div>
<div class="line">    status = <a class="code" href="group__os__abstraction.html#ga653fc3e87d91a841348be7b0a0166422">OSA_SemaWait</a>(&amp;my_sem, 10);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">switch</span> (status)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__os__abstraction.html#ggac620802974e82799bde8d7eeadecaea2a5ff8ef02cb571d5d5f92a7e816719a3d">kStatus_OSA_Idle</a>:</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__os__abstraction.html#ggac620802974e82799bde8d7eeadecaea2aa4598af8363b288290d945d9853c4b32">kStatus_OSA_Success</a>:</div>
<div class="line">            <span class="comment">// ...</span></div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__os__abstraction.html#ggac620802974e82799bde8d7eeadecaea2afe784ce9a332a9b671d6b372840c60a1">kStatus_OSA_Error</a>:</div>
<div class="line">            <span class="comment">// ...</span></div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__os__abstraction.html#ggac620802974e82799bde8d7eeadecaea2a8a3efc503d4b3a9f785d00b6f5a72b53">kStatus_OSA_Timeout</a>:</div>
<div class="line">            <span class="comment">// ...</span></div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">}</div>
</div><!-- fragment -->Wait the semaphore at the start of the task, if kStatus_OSA_Idle is received. Return and let other tasks run. Then, post_task has a chance to post my_sem.<br/>
 The other method is using the function <a class="el" href="group__os__abstraction__bm.html#ga5b58984db92662727d4c6e612029ebb4" title="Calls all task functions one time except for the current task. ">OSA_PollAllOtherTasks()</a>. This function calls all other tasks one at a time and then post_task can post my_sem.<div class="fragment"><div class="line"><span class="keywordtype">void</span> post_task(<a class="code" href="group__os__abstraction__bm.html#ga90774a4d1708f3e210d94c829b44eb86">task_param_t</a> param)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">    <a class="code" href="group__os__abstraction.html#gaa5034a9787f489d989f22a06e509a192">OSA_SemaPost</a>(&amp;my_sem);</div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> wait_task(<a class="code" href="group__os__abstraction__bm.html#ga90774a4d1708f3e210d94c829b44eb86">task_param_t</a> param)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">    status = <a class="code" href="group__os__abstraction.html#ga653fc3e87d91a841348be7b0a0166422">OSA_SemaWait</a>(&amp;my_sem, 10);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group__os__abstraction.html#ggac620802974e82799bde8d7eeadecaea2a5ff8ef02cb571d5d5f92a7e816719a3d">kStatus_OSA_Idle</a> == status)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="group__os__abstraction__bm.html#ga5b58984db92662727d4c6e612029ebb4">OSA_PollAllOtherTasks</a>();</div>
<div class="line">        status = <a class="code" href="group__os__abstraction.html#ga653fc3e87d91a841348be7b0a0166422">OSA_SemaWait</a>(&amp;my_sem, 10);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">}</div>
</div><!-- fragment -->The limitation of this method is that only one task can use the <a class="el" href="group__os__abstraction__bm.html#ga5b58984db92662727d4c6e612029ebb4" title="Calls all task functions one time except for the current task. ">OSA_PollAllOtherTasks()</a> function. If both task_A and task_B call this function, then the stack overflow may occur, because the call stack flows like this: task_A -&gt; OSA_PollAllOtherTasks -&gt; task_B -&gt; OSA_PollAllOtherTasks -&gt; task_A -&gt; ...<h1>Bare Metal Mutex</h1>
Bare metal OSA implements mutex as a binary semaphore, which is different than the RTOS mutex. Applications could choose whether to use if for the bare metal.<h1>Bare Metal Time management</h1>
Bare metal OSA implements two configurations for the time management. The first one uses the low power timer. The second one is empty. In other words, this configuration disables time management in bare metal OSA. To use a different configuration, set the macro FSL_OSA_BM_TIMER_CONFIG in the file fsl_os_abstraction_bm.h.<h2>Time management with LPTMR</h2>
To use the low power timer in bare metal OSA, define the FSL_OSA_BM_TIMER_CONFIG as the FSL_OSA_BM_TIMER_LPTMER. <br/>
 Bare metal OSA maintains a system time with the low power timer module. Applications can get the system time in milliseconds using the function <a class="el" href="group__os__abstraction.html#ga13573345b625c22855e4c1d02fdbb284" title="Gets the current time since system boot in milliseconds. ">OSA_TimeGetMsec()</a>. At the same time, all wait functions, such as <a class="el" href="group__os__abstraction.html#ga653fc3e87d91a841348be7b0a0166422" title="Pending a semaphore with timeout. ">OSA_SemaWait()</a> and <a class="el" href="group__os__abstraction.html#ga3b861498a697c65ecf3b1487037bf262" title="Waits for specified event flags to be set. ">OSA_EventWait()</a>, depend on the system time. Low power timer module is set up in the function <a class="el" href="group__os__abstraction.html#gab7bddc0deaf1ef6a2f8d2f2b8b337094" title="Initializes the RTOS services. ">OSA_Init()</a>. To use this timer function, ensure that the <a class="el" href="group__os__abstraction.html#gab7bddc0deaf1ef6a2f8d2f2b8b337094" title="Initializes the RTOS services. ">OSA_Init()</a> function is called. Note that the low power timer provides only 16-bit time count and wraps every 65536 ms. Use these three functions:</p>
<ol type="1">
<li><a class="el" href="group__os__abstraction.html#ga80ec77b248ae8f3d564727e0cb78eaee" title="Delays execution for a number of milliseconds. ">OSA_TimeDelay()</a> cannot delay longer than 65536 ms.</li>
<li>Wait functions, such as <a class="el" href="group__os__abstraction.html#ga653fc3e87d91a841348be7b0a0166422" title="Pending a semaphore with timeout. ">OSA_SemaWait()</a>, cannot set timeout longer than 65536 ms, however, OSA_WAIT_FOREVER is allowed.</li>
<li><a class="el" href="group__os__abstraction.html#ga13573345b625c22855e4c1d02fdbb284" title="Gets the current time since system boot in milliseconds. ">OSA_TimeGetMsec()</a> wraps every 65536 ms; if it does not meet the requirement, use a different timer module in application.</li>
</ol>
<h2>Disable time management in bare metal OSA</h2>
To disable time management bare metal OSA, define the FSL_OSA_BM_TIMER_CONFIG as the FSL_OSA_BM_TIMER_NONE. <br/>
 With this configuration, the LPTMR is not used by bare metal OSA and the footprint is smaller. Time services such OSA_TimeGetMsec and OSA_TimeDelay can't be used any more. At the same time, the wait functions such as <a class="el" href="group__os__abstraction.html#ga653fc3e87d91a841348be7b0a0166422" title="Pending a semaphore with timeout. ">OSA_SemaWait()</a> and <a class="el" href="group__os__abstraction.html#ga3b861498a697c65ecf3b1487037bf262" title="Waits for specified event flags to be set. ">OSA_EventWait()</a> can only use 0 or OSA_WAIT_FOREVER as the parameter timeout.<h2>User-defined time management</h2>
When the LPTMR is occupied by other tasks and bare metal OSA is used to provide time services, bare metal OSA must use other timers for the time services. In this case, customizeS these functions defined in fsl_os_abstraction_bm.c:<div class="fragment"><div class="line"><span class="comment">/* Initializes timer. </span></div>
<div class="line"><span class="comment">void OSA_TimeInit(void);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Gets the time delta between time_start and time_end. This function</span></div>
<div class="line"><span class="comment"> * should consider the timer counter overflow.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">uint32_t OSA_TimeDiff(uint32_t time_start, uint32_t time_end);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">/* Gets current time in milliseconds. </span></div>
<div class="line"><span class="comment">uint32_t OSA_TimeGetMsec(void);</span></div>
</div><!-- fragment -->There are two methods to customize these functions:</p>
<ol type="1">
<li>Modify the functions in fsl_os_abstraction_bm.c directly.</li>
<li>Define the functions in the application, which means that the functions in fsl_os_abstraction_bm.c are overridden. </li>
</ol>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structsemaphore__t" id="structsemaphore__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct semaphore_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:ae48a6200f3625d1c3a6efe8cd0d2f58c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae48a6200f3625d1c3a6efe8cd0d2f58c"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ae48a6200f3625d1c3a6efe8cd0d2f58c">isWaiting</a></td></tr>
<tr class="memdesc:ae48a6200f3625d1c3a6efe8cd0d2f58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is any task waiting for a timeout on this object. <br/></td></tr>
<tr class="separator:ae48a6200f3625d1c3a6efe8cd0d2f58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09113d6c45205405bee97dd21d678d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab09113d6c45205405bee97dd21d678d1"></a>
volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ab09113d6c45205405bee97dd21d678d1">semCount</a></td></tr>
<tr class="memdesc:ab09113d6c45205405bee97dd21d678d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The count value of the object. <br/></td></tr>
<tr class="separator:ab09113d6c45205405bee97dd21d678d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac766dca95b95cc91ff2e1de38aeb60f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac766dca95b95cc91ff2e1de38aeb60f1"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ac766dca95b95cc91ff2e1de38aeb60f1">time_start</a></td></tr>
<tr class="memdesc:ac766dca95b95cc91ff2e1de38aeb60f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time to start timeout. <br/></td></tr>
<tr class="separator:ac766dca95b95cc91ff2e1de38aeb60f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1d0273ebf4106140af0f4b69dc4cb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada1d0273ebf4106140af0f4b69dc4cb1"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ada1d0273ebf4106140af0f4b69dc4cb1">timeout</a></td></tr>
<tr class="memdesc:ada1d0273ebf4106140af0f4b69dc4cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout to wait in milliseconds. <br/></td></tr>
<tr class="separator:ada1d0273ebf4106140af0f4b69dc4cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="structmutex__t" id="structmutex__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct mutex_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a8aabb2adca63fecf51370c3fb53262b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8aabb2adca63fecf51370c3fb53262b6"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#a8aabb2adca63fecf51370c3fb53262b6">isWaiting</a></td></tr>
<tr class="memdesc:a8aabb2adca63fecf51370c3fb53262b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is any task waiting for a timeout on this mutex. <br/></td></tr>
<tr class="separator:a8aabb2adca63fecf51370c3fb53262b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdb392ab9f49cb9c065218de82897a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fdb392ab9f49cb9c065218de82897a2"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#a7fdb392ab9f49cb9c065218de82897a2">isLocked</a></td></tr>
<tr class="memdesc:a7fdb392ab9f49cb9c065218de82897a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the object locked or not. <br/></td></tr>
<tr class="separator:a7fdb392ab9f49cb9c065218de82897a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaacd05ad16d658a841ea0483aa43f229"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaacd05ad16d658a841ea0483aa43f229"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#aaacd05ad16d658a841ea0483aa43f229">time_start</a></td></tr>
<tr class="memdesc:aaacd05ad16d658a841ea0483aa43f229"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time to start timeout. <br/></td></tr>
<tr class="separator:aaacd05ad16d658a841ea0483aa43f229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780316dbcf772f6dd075b89e6486a437"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a780316dbcf772f6dd075b89e6486a437"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#a780316dbcf772f6dd075b89e6486a437">timeout</a></td></tr>
<tr class="memdesc:a780316dbcf772f6dd075b89e6486a437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout to wait in milliseconds. <br/></td></tr>
<tr class="separator:a780316dbcf772f6dd075b89e6486a437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac979df92cafe41f627f2568cb7c89a59"><td class="memItemLeft" align="right" valign="top">LWSEM_STRUCT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ac979df92cafe41f627f2568cb7c89a59">sema</a></td></tr>
<tr class="memdesc:ac979df92cafe41f627f2568cb7c89a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lwsem structure.  <a href="#ac979df92cafe41f627f2568cb7c89a59">More...</a><br/></td></tr>
<tr class="separator:ac979df92cafe41f627f2568cb7c89a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778cf4e788153c24b1c126157d4ab4b3"><td class="memItemLeft" align="right" valign="top">_task_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#a778cf4e788153c24b1c126157d4ab4b3">owner</a></td></tr>
<tr class="memdesc:a778cf4e788153c24b1c126157d4ab4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task who locks this mutex.  <a href="#a778cf4e788153c24b1c126157d4ab4b3">More...</a><br/></td></tr>
<tr class="separator:a778cf4e788153c24b1c126157d4ab4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="ac979df92cafe41f627f2568cb7c89a59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWSEM_STRUCT mutex_t::sema</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a778cf4e788153c24b1c126157d4ab4b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_task_id mutex_t::owner</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structevent__t" id="structevent__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct event_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a008c904a9e85e0c4d0e276554807883d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a008c904a9e85e0c4d0e276554807883d"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#a008c904a9e85e0c4d0e276554807883d">isWaiting</a></td></tr>
<tr class="memdesc:a008c904a9e85e0c4d0e276554807883d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is any task waiting for a timeout on this event. <br/></td></tr>
<tr class="separator:a008c904a9e85e0c4d0e276554807883d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2b3f76c7a312407c24d67045a70c25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a2b3f76c7a312407c24d67045a70c25"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#a3a2b3f76c7a312407c24d67045a70c25">time_start</a></td></tr>
<tr class="memdesc:a3a2b3f76c7a312407c24d67045a70c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time to start timeout. <br/></td></tr>
<tr class="separator:a3a2b3f76c7a312407c24d67045a70c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5834d5bd66eefe0625fa90cbc095d2b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5834d5bd66eefe0625fa90cbc095d2b9"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#a5834d5bd66eefe0625fa90cbc095d2b9">timeout</a></td></tr>
<tr class="memdesc:a5834d5bd66eefe0625fa90cbc095d2b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout to wait in milliseconds. <br/></td></tr>
<tr class="separator:a5834d5bd66eefe0625fa90cbc095d2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d71e2dffc5ca2c382f7ff2e5c8f187"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1d71e2dffc5ca2c382f7ff2e5c8f187"></a>
volatile <a class="el" href="group__os__abstraction__bm.html#ga79a78f74479544e6d60e4ecaedf83752">event_flags_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#af1d71e2dffc5ca2c382f7ff2e5c8f187">flags</a></td></tr>
<tr class="memdesc:af1d71e2dffc5ca2c382f7ff2e5c8f187"><td class="mdescLeft">&#160;</td><td class="mdescRight">The flags status. <br/></td></tr>
<tr class="separator:af1d71e2dffc5ca2c382f7ff2e5c8f187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc60a9072236c3f86e1b1644406a4c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbc60a9072236c3f86e1b1644406a4c6"></a>
<a class="el" href="group__os__abstraction.html#gad68a2998cc936df026564393e11f1e1a">osa_event_clear_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#adbc60a9072236c3f86e1b1644406a4c6">clearMode</a></td></tr>
<tr class="memdesc:adbc60a9072236c3f86e1b1644406a4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto clear or manual clear. <br/></td></tr>
<tr class="separator:adbc60a9072236c3f86e1b1644406a4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="structtask__control__block__t" id="structtask__control__block__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct task_control_block_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a769818bc11ec679785a6a0c8b8a22018"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a769818bc11ec679785a6a0c8b8a22018"></a>
<a class="el" href="group__os__abstraction__free__rtos.html#gace191eba2cf262e6b56ab557e8ae24df">task_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#a769818bc11ec679785a6a0c8b8a22018">p_func</a></td></tr>
<tr class="memdesc:a769818bc11ec679785a6a0c8b8a22018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task's entry. <br/></td></tr>
<tr class="separator:a769818bc11ec679785a6a0c8b8a22018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d27a3a4aa8ff46d82d6265a4266ab36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d27a3a4aa8ff46d82d6265a4266ab36"></a>
<a class="el" href="group__os__abstraction__bm.html#ga90774a4d1708f3e210d94c829b44eb86">task_param_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#a1d27a3a4aa8ff46d82d6265a4266ab36">param</a></td></tr>
<tr class="memdesc:a1d27a3a4aa8ff46d82d6265a4266ab36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task's parameter. <br/></td></tr>
<tr class="separator:a1d27a3a4aa8ff46d82d6265a4266ab36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a1b9ba901cfdc48b4031bab1936aad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12a1b9ba901cfdc48b4031bab1936aad"></a>
struct TaskControlBlock *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#a12a1b9ba901cfdc48b4031bab1936aad">next</a></td></tr>
<tr class="memdesc:a12a1b9ba901cfdc48b4031bab1936aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to next task control block. <br/></td></tr>
<tr class="separator:a12a1b9ba901cfdc48b4031bab1936aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0029799e0fcf74baaa1bc9be165df3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a0029799e0fcf74baaa1bc9be165df3"></a>
struct TaskControlBlock *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#a6a0029799e0fcf74baaa1bc9be165df3">prev</a></td></tr>
<tr class="memdesc:a6a0029799e0fcf74baaa1bc9be165df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to previous task control block. <br/></td></tr>
<tr class="separator:a6a0029799e0fcf74baaa1bc9be165df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="structmsg__queue__t" id="structmsg__queue__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct msg_queue_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a1e1376fb579cd7452ec82b74e20becc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e1376fb579cd7452ec82b74e20becc0"></a>
uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#a1e1376fb579cd7452ec82b74e20becc0">queueMem</a></td></tr>
<tr class="memdesc:a1e1376fb579cd7452ec82b74e20becc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Points to the queue memory. <br/></td></tr>
<tr class="separator:a1e1376fb579cd7452ec82b74e20becc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9821e6a3f798ee9f4e3f952c2a214ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9821e6a3f798ee9f4e3f952c2a214ac"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ad9821e6a3f798ee9f4e3f952c2a214ac">number</a></td></tr>
<tr class="memdesc:ad9821e6a3f798ee9f4e3f952c2a214ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of messages in the queue. <br/></td></tr>
<tr class="separator:ad9821e6a3f798ee9f4e3f952c2a214ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa911786bd45fa3e09ccdaf4d9ac56228"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa911786bd45fa3e09ccdaf4d9ac56228"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#aa911786bd45fa3e09ccdaf4d9ac56228">size</a></td></tr>
<tr class="memdesc:aa911786bd45fa3e09ccdaf4d9ac56228"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size in words of each message. <br/></td></tr>
<tr class="separator:aa911786bd45fa3e09ccdaf4d9ac56228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52c783c93cd4f8137b84be35e211dde"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac52c783c93cd4f8137b84be35e211dde"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#ac52c783c93cd4f8137b84be35e211dde">head</a></td></tr>
<tr class="memdesc:ac52c783c93cd4f8137b84be35e211dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the next message to be read. <br/></td></tr>
<tr class="separator:ac52c783c93cd4f8137b84be35e211dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e20ae9630c8753c5d28082342f4bab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50e20ae9630c8753c5d28082342f4bab"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#a50e20ae9630c8753c5d28082342f4bab">tail</a></td></tr>
<tr class="memdesc:a50e20ae9630c8753c5d28082342f4bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the next place to write to. <br/></td></tr>
<tr class="separator:a50e20ae9630c8753c5d28082342f4bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079cc807babeda1b0aa1a3b140093be7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a079cc807babeda1b0aa1a3b140093be7"></a>
<a class="el" href="group__os__abstraction__bm.html#structsemaphore__t">semaphore_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#a079cc807babeda1b0aa1a3b140093be7">queueSem</a></td></tr>
<tr class="memdesc:a079cc807babeda1b0aa1a3b140093be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semaphore wakeup tasks waiting for msg. <br/></td></tr>
<tr class="separator:a079cc807babeda1b0aa1a3b140093be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7ee3f65b00f6e92129abe757286323"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e7ee3f65b00f6e92129abe757286323"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__abstraction__bm.html#a2e7ee3f65b00f6e92129abe757286323">isEmpty</a></td></tr>
<tr class="memdesc:a2e7ee3f65b00f6e92129abe757286323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether queue is empty. <br/></td></tr>
<tr class="separator:a2e7ee3f65b00f6e92129abe757286323"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga5ffcf301e911e4911ebb33f6d120b79b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSL_OSA_BM_TIMER_NONE&#160;&#160;&#160;0U</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gadd1345edb8713252108dffd4f7d961ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSL_OSA_BM_TIMER_LPTMER&#160;&#160;&#160;1U</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gad95549b5ccdee2644886381c47507d1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSL_OSA_BM_TIMER_CONFIG&#160;&#160;&#160;<a class="el" href="group__os__abstraction__bm.html#gadd1345edb8713252108dffd4f7d961ab">FSL_OSA_BM_TIMER_LPTMER</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5c4bbd97efaa670e198fad62038ba771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSA_WAIT_FOREVER&#160;&#160;&#160;0xFFFFFFFFU</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga11a0fb3f79cc6bab55d41a1f2e1789da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TASK_MAX_NUM&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0b8cb2e5f9f9863520c4c9e4c3c47e3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSL_OSA_TIME_RANGE&#160;&#160;&#160;0xFFFFU</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga50f035ff4993767f49ca67b3847bfec4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSA_DEFAULT_INT_HANDLER&#160;&#160;&#160;((<a class="el" href="group__os__abstraction.html#ga319b0b915c46a8b1adf9ef2c1ec3e7e1">osa_int_handler_t</a>)(&amp;<a class="el" href="group__os__abstraction__bm.html#ga4fcbeb17b7f10e57e297bf6b12a07e7e">DefaultISR</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga37ea523ee533242cf8b8c3706a93d818"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSA_TASK_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">stackSize&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__os__abstraction__bm.html#ga184cb36aad264b6917c489bbc2b793a5">task_stack_t</a>* task##_stack = NULL;   <a class="code" href="group__os__abstraction__bm.html#ga2d867ba7d27cb355a1827c2c11889bcc">\</a></div>
<div class="line"><a class="code" href="group__os__abstraction__bm.html#ga2d867ba7d27cb355a1827c2c11889bcc">    task_handler_t</a> task##_task_handler</div>
<div class="ttc" id="group__os__abstraction__bm_html_ga184cb36aad264b6917c489bbc2b793a5"><div class="ttname"><a href="group__os__abstraction__bm.html#ga184cb36aad264b6917c489bbc2b793a5">task_stack_t</a></div><div class="ttdeci">uint32_t task_stack_t</div><div class="ttdoc">Type for a task stack. </div><div class="ttdef"><b>Definition:</b> fsl_os_abstraction_bm.h:104</div></div>
<div class="ttc" id="group__os__abstraction__bm_html_ga2d867ba7d27cb355a1827c2c11889bcc"><div class="ttname"><a href="group__os__abstraction__bm.html#ga2d867ba7d27cb355a1827c2c11889bcc">task_handler_t</a></div><div class="ttdeci">task_control_block_t * task_handler_t</div><div class="ttdoc">Type for a task handler, returned by the OSA_TaskCreate function. </div><div class="ttdef"><b>Definition:</b> fsl_os_abstraction_bm.h:101</div></div>
</div><!-- fragment --><p>This macro defines resources for a task statically. Then, the OSA_TaskCreate creates the task based-on these resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task function. </td></tr>
    <tr><td class="paramname">stackSize</td><td>The stack size this task needs in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad27d9381348700acda99a4eedad3a0d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_QUEUE_DECLARE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">number, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">uint32_t queueMem_##name[number * size]; <a class="code" href="group__os__abstraction__free__rtos.html#ga8e71879c8c06dbd0874ae3405fcd0352">\</a></div>
<div class="line"><a class="code" href="group__os__abstraction__free__rtos.html#ga8e71879c8c06dbd0874ae3405fcd0352">                                              msg_queue_t</a> entity_##name = {            \</div>
<div class="line">                                                  .queueMem = queueMem_##name          \</div>
<div class="line">                                              };                                       <a class="code" href="group__os__abstraction__free__rtos.html#ga8e71879c8c06dbd0874ae3405fcd0352">\</a></div>
<div class="line"><a class="code" href="group__os__abstraction__free__rtos.html#ga8e71879c8c06dbd0874ae3405fcd0352">                                              msg_queue_t</a> *name = &amp;(entity_##name)</div>
<div class="ttc" id="group__os__abstraction__free__rtos_html_ga8e71879c8c06dbd0874ae3405fcd0352"><div class="ttname"><a href="group__os__abstraction__free__rtos.html#ga8e71879c8c06dbd0874ae3405fcd0352">msg_queue_t</a></div><div class="ttdeci">xQueueHandle msg_queue_t</div><div class="ttdoc">Type for a message queue declaration and creation. </div><div class="ttdef"><b>Definition:</b> fsl_os_abstraction_free_rtos.h:123</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Identifier for the memory region. </td></tr>
    <tr><td class="paramname">number</td><td>Number of elements in the queue. </td></tr>
    <tr><td class="paramname">size</td><td>Size of every element in words. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga4fcbeb17b7f10e57e297bf6b12a07e7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DefaultISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5b58984db92662727d4c6e612029ebb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OSA_PollAllOtherTasks </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function calls all other task functions one time. If current task is waiting for an event triggered by other tasks, this function could be used to trigger the event.</p>
<dl class="section note"><dt>Note</dt><dd>There should be only one task calls this function, if more than one task call this function, stack overflow may occurs. Be careful to use this function. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer">Thu Sep 24 2015 &copy; 2015 Freescale Semiconductor, Inc. All rights reserved.
    </li>
  </ul>
</div>
</body>
</html>
